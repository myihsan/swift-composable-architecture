{"kind":"article","seeAlsoSections":[{"title":"Upgrade guides","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwiftConcurrency"],"anchor":"Upgrade-guides","generated":true}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/composablearchitecture\/migratingtothereducerprotocol"]}],"sections":[],"abstract":[{"text":"Learn how to migrate existing applications to use the new ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","type":"reference"},{"text":", in both Swift 5.7 and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift 5.6."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"Migrating an application that uses the "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"type":"text","text":" type over to the new "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","type":"reference","isActive":true},{"type":"text","text":" can be"},{"text":" ","type":"text"},{"type":"text","text":"done slowly and incrementally. The library provides the tools to convert one reducer at a time,"},{"type":"text","text":" "},{"text":"allowing you to plug protocol-style reducers into old-style reducers, and vice-versa.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Although we recommend migrating your code when you have time, the newest version of the library"},{"type":"text","text":" "},{"type":"text","text":"is still 100% backwards compatible with all previous versions. The "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","type":"reference","isActive":true},{"text":" type is now","type":"text"},{"text":" ","type":"text"},{"text":"“soft” deprecated, which means we consider it deprecated, and it says so in the documentation, but","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you will not get any warnings about it. Sometime in the future, we will officially deprecate it,"},{"text":" ","type":"text"},{"type":"text","text":"and then sometime even later we will remove it so that we can rename the protocol to "},{"type":"codeVoice","code":"Reducer"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"This article outlines a number of strategies you can employ to convert your reducers to the protocol","type":"text"},{"type":"text","text":" "},{"text":"when you are ready:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"reference","isActive":true,"identifier":"#Leaf-node-features"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"#Composition-of-features","type":"reference"}]}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"#Optional-and-pullback-reducers"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"#For-each-reducers"}]}]},{"content":[{"inlineContent":[{"identifier":"#Binding-reducers","isActive":true,"type":"reference"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"#Dependencies","type":"reference","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"#Stores","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"#Testing","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Embedding-old-reducer-values-in-a-new-reducer-conformance"}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"#Migration-using-Swift-56","isActive":true}],"type":"paragraph"}]}]},{"level":2,"text":"Leaf node features","type":"heading","anchor":"Leaf-node-features"},{"type":"paragraph","inlineContent":[{"text":"The simplest parts of an application to convert to ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true,"type":"reference"},{"text":" are leaf node features that","type":"text"},{"text":" ","type":"text"},{"text":"do not compose multiple reducers at once. For example, suppose you have a feature domain with a","type":"text"},{"type":"text","text":" "},{"text":"dependency like this:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct FeatureState {","  \/\/ ...","}","enum FeatureAction {","  \/\/ ...","}","struct FeatureEnvironment {","  var date: () -> Date","}","","let featureReducer = Reducer<","  FeatureState,","  FeatureAction,","  FeatureEnvironment","> { state, action, environment in","  switch action {","  \/\/ ...","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"You can convert this to the protocol style by:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Creating a dedicated type that conforms to the "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true,"type":"reference"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Nest the state and action types inside this new type, and rename them to just ","type":"text"},{"type":"codeVoice","code":"State"},{"text":" and","type":"text"},{"text":" ","type":"text"},{"code":"Action","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Move the fields on the environment to be fields on this new reducer type, and delete the"},{"text":" ","type":"text"},{"type":"text","text":"environment type."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Move the reducer’s closure implementation to the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/reduce(into:action:)-8yinq","isActive":true},{"text":"","type":"text"},{"type":"text","text":" "},{"type":"text","text":"method."}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"Performing these 4 steps on the feature produces the following:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Feature: ReducerProtocol {","  struct State {","    \/\/ ...","  }","","  enum Action {","    \/\/ ...","  }","","  let date: () -> Date","","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    switch action {","    \/\/ ...","    }","  }","}"]},{"inlineContent":[{"type":"text","text":"Once this feature’s domain and reducer are converted to the protocol-style you will invariably have"},{"text":" ","type":"text"},{"text":"compiler errors wherever you were referring to the old types. For example, suppose you have a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"parent feature that is currently trying to embed the old-style domain and reducer into its domain"},{"type":"text","text":" "},{"text":"and reducer:","type":"text"}],"type":"paragraph"},{"code":["struct ParentState { ","  var feature: FeatureState","  \/\/ ...","}","","enum ParentAction {","  case feature(FeatureAction)","  \/\/ ...","}","","struct ParentEnvironment {","  var date: () -> Date","  var dependency: Dependency","  \/\/ ...","}","","let parentReducer = Reducer<ParentState, ParentAction, ParentEnvironment>.combine(","  featureReducer","    .pullback(","      state: \\.feature, ","      action: \/ParentAction.feature, ","      environment: {  ","        FeatureEnvironment(date: $0.date)","      }","    ),","","  Reducer { state, action, environment in ","    \/\/ ...","  }",")"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can be updated to work with the new "},{"type":"codeVoice","code":"Feature"},{"type":"text","text":" reducer conformance by first fixing any"},{"type":"text","text":" "},{"type":"text","text":"references to the state and action types:"}]},{"type":"codeListing","syntax":"swift","code":["struct ParentState { ","  var feature: Feature.State","  \/\/ ...","}","","enum ParentAction {","  case feature(Feature.Action)","  \/\/ ...","}"]},{"inlineContent":[{"type":"text","text":"And then the "},{"code":"parentReducer","type":"codeVoice"},{"text":" can be fixed by making use of the helper ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/init(_:)-42p1a"},{"text":" ","type":"text"},{"type":"text","text":"which aids in converting protocol-style reducers into old-style reducers. It is initialized with a"},{"type":"text","text":" "},{"text":"closure that is passed an environment, which is the one thing protocol-style reducers don’t have,","type":"text"},{"text":" ","type":"text"},{"text":"and you  are to return a protocol-style reducer:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let parentReducer = Reducer<ParentState, ParentAction, ParentEnvironment>.combine(","  AnyReducer { environment in","    Feature(date: environment.date)","  }","  .pullback(","    state: \\.feature, ","    action: \/ParentAction.feature, ","    environment: { $0 }","  ),","","  Reducer { state, action, environment in ","    \/\/ ...","  }",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer"},{"text":"’s only purpose is to convert the protocol-style reducer to the","type":"text"},{"text":" ","type":"text"},{"text":"old-style so that it can be plugged into existing old-style reducers. You can then chain on the","type":"text"},{"text":" ","type":"text"},{"text":"operators you were using before to the end of the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer","isActive":true},{"type":"text","text":" usage."}]},{"inlineContent":[{"type":"text","text":"With those few changes your application should now build, and you have successfully converted one"},{"type":"text","text":" "},{"text":"leaf node feature to the new ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true,"type":"reference"},{"type":"text","text":"-style of doing things."}],"type":"paragraph"},{"text":"Composition of features","level":2,"type":"heading","anchor":"Composition-of-features"},{"inlineContent":[{"text":"Some features in your application are an amalgamation of other features. For example, a tab-based","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"application may have a separate domain and reducer for each tab, and then an app-level domain and"},{"type":"text","text":" "},{"type":"text","text":"reducer that composes everything together."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose that all of the tab features have already been converted to the protocol-style:"}]},{"syntax":"swift","type":"codeListing","code":["struct TabA: ReducerProtocol {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    \/\/ ...","  }","}","","struct TabB: ReducerProtocol {","  \/\/ ...","}","","struct TabC: ReducerProtocol {","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"text":"But, suppose that the app-level domain and reducer have not yet been converted and so have compiler","type":"text"},{"type":"text","text":" "},{"type":"text","text":"errors due to referencing types and values that no longer exist:"}]},{"code":["struct AppState {","  var tabA: TabAState","  var tabB: TabBState","  var tabC: TabCState","}","","enum AppAction {","  case tabA(TabAAction)","  case tabB(TabBAction)","  case tabC(TabCAction)","}","","struct AppEnvironment {}","","let appReducer = Reducer<","  AppState, ","  AppAction, ","  AppEnvironment","> { state, action, environment in ","  \/\/ ...","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"To convert this to the protocol-style we again introduce a new type that conforms to the"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true},{"text":", we nest the domain types inside the conformance, we inline the environment","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"fields, but this time we use the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/body-7foai"},{"type":"text","text":" requirement of the"},{"type":"text","text":" "},{"type":"text","text":"protocol to describe how to compose multiple reducers:"}],"type":"paragraph"},{"code":["struct AppReducer: ReducerProtocol {","  struct State {","    var tabA: TabA.State","    var tabB: TabB.State","    var tabC: TabC.State","  }","","  enum Action {","    case tabA(TabA.Action)","    case tabB(TabB.Action)","    case tabC(TabC.Action)","  }","","  var body: some ReducerProtocol<State, Action> {","    Scope(state: \\.tabA, action: \/Action.tabA) {","      TabA()","    }","    Scope(state: \\.tabB, action: \/Action.tabC) {","      TabB()","    }","    Scope(state: \\.tabB, action: \/Action.tabC) {","      TabC()","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"With those few small changes we have now converted a composition of many reducers into the new"},{"type":"text","text":" "},{"text":"protocol-style.","type":"text"}],"type":"paragraph"},{"text":"Optional and pullback reducers","level":2,"anchor":"Optional-and-pullback-reducers","type":"heading"},{"inlineContent":[{"type":"text","text":"A common pattern in the Composable Architecture is to model a feature that can be presented and"},{"type":"text","text":" "},{"text":"dismissed as optional state. For example, suppose you have the feature’s domain and reducer modeled","type":"text"},{"type":"text","text":" "},{"text":"like so:","type":"text"}],"type":"paragraph"},{"code":["struct FeatureState { ","  \/\/ ...","}","struct FeatureAction { ","  \/\/ ...","}","struct FeatureEnvironment { ","  var date: () -> Date","}","","let featureReducer = Reducer<","  FeatureState, ","  FeatureAction, ","  FeatureEnvironment","> { state, action, environment in","  \/\/ Feature logic","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Then, the parent feature can embed this child feature as an optional in its state:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct ParentState {","  var feature: FeatureState?","  \/\/ ...","}","enum ParentAction {","  case feature(FeatureAction)","  \/\/ ...","}","struct ParentEnvironment {","  var date: () -> Date","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A non-"},{"type":"codeVoice","code":"nil"},{"text":" value for ","type":"text"},{"type":"codeVoice","code":"feature"},{"type":"text","text":" indicates that the feature view is being presented, and when it"},{"type":"text","text":" "},{"type":"text","text":"switches to "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" the view should be dismissed. The actual showing and hiding of the view can be"},{"type":"text","text":" "},{"text":"done using the ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/IfLetStore","isActive":true,"type":"reference"},{"text":" SwiftUI view.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In order to construct a single reducer that can handle the logic for the parent domain as well as","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"allow the child feature to run its logic on the "},{"type":"codeVoice","code":"feature"},{"text":" state when non-","type":"text"},{"type":"codeVoice","code":"nil"},{"text":", we can make use the","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/optional(file:fileID:line:)"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/pullback(state:action:environment:)"},{"text":" ","type":"text"},{"type":"text","text":"operators:"}]},{"code":["let parentReducer = Reducer<","  ParentState,","  ParentAction,","  ParentEnvironment",">.combine( ","  featureReducer","    .optional()","    .pullback(","      state: \\.feature, ","      action: \/ParentAction.feature, ","      environment: { FeatureEnvironment(date: $0.date) }","    ),","","  Reducer { state, action, environment in","    \/\/ Parent logic","  }",")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"It seems complex, but we have now combined the logic for the parent feature and child feature into","type":"text"},{"type":"text","text":" "},{"type":"text","text":"one package, and the child feature will only run when the state is non-"},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Migrating the "},{"code":"featureReducer","type":"codeVoice"},{"type":"text","text":" to the protocol by following the earlier instructions will"},{"type":"text","text":" "},{"text":"yield a new ","type":"text"},{"type":"codeVoice","code":"Feature"},{"text":" type that conforms to ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true,"type":"reference"},{"type":"text","text":", and the "},{"type":"codeVoice","code":"parentReducer"},{"type":"text","text":" will"},{"text":" ","type":"text"},{"type":"text","text":"look something like this:"}],"type":"paragraph"},{"syntax":"swift","code":["let parentReducer = Reducer<","  ParentState,","  ParentAction,","  ParentEnvironment",">.combine( ","  AnyReducer { environment in","    Feature(date: environment.date)","  }","  .optional()","  .pullback(","    state: \\.feature, ","    action: \/ParentAction.feature, ","    environment: { FeatureEnvironment(date: $0.date) }","  ),","","  Reducer { state, action, environment in","    \/\/ Parent logic","  }",")"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the question is, how do we migrate "},{"type":"codeVoice","code":"parentReducer"},{"type":"text","text":" to a protocol conformance?"}]},{"inlineContent":[{"type":"text","text":"This gives us an opportunity to improve the correctness of this code. It turns out there is a gotcha"},{"type":"text","text":" "},{"text":"with the ","type":"text"},{"type":"codeVoice","code":"optional"},{"text":" operator: it must be run ","type":"text"},{"inlineContent":[{"type":"text","text":"before"}],"type":"emphasis"},{"text":" the parent logic runs. If it is not, then it","type":"text"},{"text":" ","type":"text"},{"text":"is possible for a child action to come into the system, the parent observes the action and decides to","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" out the child state, and then the child reducer will not get a chance to react to the action."},{"type":"text","text":" "},{"type":"text","text":"This can cause subtle bugs, and so we have documentation advising you to order things the correct"},{"type":"text","text":" "},{"type":"text","text":"way, and if we detect a child action while state is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" we display a runtime warning."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A "},{"code":"Parent","type":"codeVoice"},{"text":" reducer conformances can be made by implementing the","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/body-7foai"},{"type":"text","text":" property of the "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true,"type":"reference"},{"type":"text","text":", which allows you"},{"text":" ","type":"text"},{"text":"to express the parent’s logic as a composition of multiple reducers. In particular, you can use","type":"text"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reduce","isActive":true},{"type":"text","text":" entry point to implement the core parent logic, and then chain on the"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/ifLet(_:action:then:file:fileID:line:)","isActive":true,"type":"reference"},{"text":" operator to identify the optional child","type":"text"},{"type":"text","text":" "},{"text":"state that you want to run the ","type":"text"},{"type":"codeVoice","code":"Feature"},{"text":" reducer on when non-","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Parent: ReducerProtocol {","  struct State {","    var feature: Feature.State?","    \/\/ ...","  }","  enum Action {","    case feature(Feature.Action)","    \/\/ ...","  }","","  let date: () -> Date","","  var body: some ReducerProtocol<State, Action> {","    Reduce { state, action in","      \/\/ Parent logic","    }","    .ifLet(\\.feature, action: \/Action.feature) {","      Feature(date: self.date)","    }","  }","}"]},{"inlineContent":[{"text":"Because the ","type":"text"},{"type":"codeVoice","code":"ifLet"},{"type":"text","text":" operator has knowledge of both the parent and child reducers it can enforce the"},{"type":"text","text":" "},{"type":"text","text":"order to add an additional layer of correctness."}],"type":"paragraph"},{"inlineContent":[{"text":"If you are using an enum to model your state, then there is a corresponding","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/ifCaseLet(_:action:then:file:fileID:line:)","isActive":true},{"type":"text","text":" operator that can help you run a"},{"text":" ","type":"text"},{"type":"text","text":"reducer on just one case of the enum."}],"type":"paragraph"},{"anchor":"For-each-reducers","level":2,"type":"heading","text":"For-each reducers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar to "},{"code":"optional","type":"codeVoice"},{"type":"text","text":" reducers, another common pattern in applications is the use of the"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/forEach(state:action:environment:file:fileID:line:)-2ypoa"},{"type":"text","text":" to allow running a reducer"},{"text":" ","type":"text"},{"type":"text","text":"on each element of a collection. Converting such child and parent reducers will look nearly"},{"text":" ","type":"text"},{"type":"text","text":"identical to what we did above for optional reducers, but it will make use of the new"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/forEach(_:action:_:file:fileID:line:)","type":"reference","isActive":true},{"type":"text","text":" operator instead."}]},{"inlineContent":[{"type":"text","text":"In particular, the new "},{"type":"codeVoice","code":"forEach"},{"type":"text","text":" method operates on the parent reducer by specifying the collection"},{"type":"text","text":" "},{"type":"text","text":"sub-state you want to work on, and providing the element reducer you want to be able to run on"},{"text":" ","type":"text"},{"type":"text","text":"each element:"}],"type":"paragraph"},{"code":["struct Parent: ReducerProtocol {","  struct State {","    var rows: IdentifiedArrayOf<Feature.State>","    \/\/ ...","  }","  enum Action {","    case row(id: Feature.State.ID, action: Feature.Action)","    \/\/ ...","  }","","  let date: () -> Date","","  var body: some ReducerProtocol<State, Action> {","    Reduce { state, action in","      \/\/ Parent logic","    }","    .forEach(\\.rows, action: \/Action.row) {","      Feature(date: self.date)","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Binding-reducers","text":"Binding reducers","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Previously, reducers with bindable state and a binding action used the "},{"code":"Reducer.binding()","type":"codeVoice"},{"type":"text","text":" method"},{"type":"text","text":" "},{"type":"text","text":"to automatically make mutations to state before running the main logic of a reducer."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["Reducer { state, action, environment in","  \/\/ Logic to run after bindable state mutations are applied","}",".binding()"]},{"type":"paragraph","inlineContent":[{"text":"In reducer builders, use the new top-level ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/BindingReducer"},{"text":" type to specify when to apply","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"mutations to bindable state:"}]},{"type":"codeListing","syntax":"swift","code":["var body: some ReducerProtocol<State, Action> {","  Reduce { state, action in","    \/\/ Logic to run before bindable state mutations are applied","  }","","  BindingReducer()  \/\/ Apply bindable state mutations","","  Reduce { state, action in","    \/\/ Logic to run after bindable state mutations are applied","  }","}"]},{"anchor":"Dependencies","level":2,"text":"Dependencies","type":"heading"},{"inlineContent":[{"text":"In the previous sections we inlined all dependencies directly into the conforming type:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Feature: ReducerProtocol {","  let apiClient: APIClient","  let date: () -> Date","  \/\/ ...","}"]},{"inlineContent":[{"type":"text","text":"But this means that you must explicitly thread all dependencies from the root of the application"},{"type":"text","text":" "},{"text":"through to every child feature. This can be arduous and make it difficult to add, remove or change","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"dependencies."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The library comes with a tool for managing dependencies in a more ergonomic manner, and even comes","type":"text"},{"type":"text","text":" "},{"text":"with some common dependencies pre-integrated allowing you to access them with no additional work.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, the "},{"code":"date","type":"codeVoice"},{"text":" dependency ships with the library so that you can declare your feature’s","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"dependence on that functionality in the following way:"}]},{"code":["struct Feature: ReducerProtocol {","  let apiClient: APIClient","  @Dependency(\\.date) var date","  \/\/ ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"With that one declaration you can stop explicitly passing the date dependency through every layer","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of your application. A date function will be automatically provided to your feature’s reducer."}]},{"type":"paragraph","inlineContent":[{"text":"For domain-specific dependencies you can perform a little bit of upfront work to register your","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"dependency with the system, and then it will be automatically available to every layer in your"},{"type":"text","text":" "},{"text":"application:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["private enum APIClientKey: DependencyKey {","  static let liveValue = APIClient.live","}","extension DependencyValues {","  var apiClient: APIClient {","    get { self[APIClientKey.self] }","    set { self[APIClientKey.self] = newValue }","  }","}"]},{"inlineContent":[{"type":"text","text":"With that work done you can access the dependency from any feature’s reducer using the "},{"code":"@Dependency","type":"codeVoice"},{"text":" ","type":"text"},{"text":"property wrapper:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct Feature: ReducerProtocol {","  @Dependency(\\.apiClient) var apiClient","  @Dependency(\\.date) var date","  \/\/ ...","}"],"syntax":"swift"},{"inlineContent":[{"text":"For more information on designing your dependencies and providing live and test dependencies, see","type":"text"},{"type":"text","text":" "},{"type":"text","text":"our "},{"text":"doc:Testing","type":"text"},{"type":"text","text":" article."}],"type":"paragraph"},{"anchor":"Stores","type":"heading","level":2,"text":"Stores"},{"type":"paragraph","inlineContent":[{"text":"Stores can be initialized from an initial state and an instance of a type conforming to","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["FeatureView(","  store: Store(","    initialState: Feature.State(),","    reducer: Feature()","  )",")"]},{"type":"paragraph","inlineContent":[{"text":"Views that hold onto stores can also employ the ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/StoreOf","type":"reference","isActive":true},{"text":" type alias to clean up the property","type":"text"},{"type":"text","text":" "},{"text":"declaration:","type":"text"}]},{"code":["let store: StoreOf<Feature>","\/\/ Expands to:","\/\/     let store: Store<Feature.State, Feature.Action>"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Testing","level":2,"anchor":"Testing"},{"inlineContent":[{"text":"Test stores can be initialized from an initial state and an instance of a type conforming to","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: Feature.State(),","  reducer: Feature()",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default test stores will employ “test” dependencies wherever a dependency is accessed from a"},{"text":" ","type":"text"},{"type":"text","text":"reducer via the "},{"code":"@Dependency","type":"codeVoice"},{"type":"text","text":" property wrapper."}]},{"inlineContent":[{"type":"text","text":"Instead of passing an environment of test dependencies to the store, or mutating the store’s"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/environment"},{"text":", you will instead mutate the test store’s ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/dependencies","isActive":true,"type":"reference"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"override dependencies driving a feature."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, to install a test clock as the continuous clock dependency you can do the following:"}]},{"syntax":"swift","type":"codeListing","code":["let clock = TestClock()","store.dependencies.continuousClock = clock","","await store.send(.timerButtonStarted)","","await clock.advance(by: .seconds(1))","await store.receive(.timerTick) {","  $0.secondsElapsed = 1","}","","await store.send(.timerButtonStopped)"]},{"text":"Embedding old reducer values in a new reducer conformance","level":2,"type":"heading","anchor":"Embedding-old-reducer-values-in-a-new-reducer-conformance"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It may not be feasible to migrate your entire application at once, and you may find yourself"},{"text":" ","type":"text"},{"type":"text","text":"needing to compose an existing value of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":" into a type conforming to "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This can be done by passing the value and its environment of dependencies to"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reduce\/init(_:environment:)"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For example, suppose a tab of your application has not yet been converted to the protocol-style of","type":"text"},{"text":" ","type":"text"},{"text":"reducers, and it has an environment of dependencies:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct TabCState {","  \/\/ ...","}","enum TabCAction {","  \/\/ ...","}","struct TabCEnvironment {","  var date: () -> Date","}","let tabCReducer = Reducer<","  TabCState,","  TabCAction,","  TabCEnvironment","} { state, action, environment in","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"text":"It can still be embedded in ","type":"text"},{"type":"codeVoice","code":"AppReducer"},{"text":" using ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reduce\/init(_:environment:)","isActive":true,"type":"reference"},{"type":"text","text":" and passing along the"},{"type":"text","text":" "},{"type":"text","text":"necessary dependencies."}]},{"code":["struct AppReducer: ReducerProtocol {","  struct State {","    \/\/ ...","    var tabC: TabCState","  }","","  enum Action {","    \/\/ ...","    case tabC(TabCAction)","  }","","  @Dependency(\\.date) var date","","  var body: some ReducerProtocol<State, Action> {","    \/\/ ...","    Scope(state: \\.tabC, action: \/Action.tabC) {","      Reduce(","        tabCReducer,","        environment: TabCEnvironment(date: self.date)","      )","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"heading","level":2,"text":"Migration using Swift 5.6","anchor":"Migration-using-Swift-56"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The migration strategy described above for Swift 5.7 also applies to applications that are still"},{"type":"text","text":" "},{"text":"using Xcode 13 and Swift 5.6, but with one small change. When conforming your types to the","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol"},{"text":" you are not allowed to use the syntax ","type":"text"},{"code":"some ReducerProtocol<State, Action>","type":"codeVoice"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"because that is only available in Swift 5.7. Instead, you must specify "},{"code":"Reduce<State, Action>","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"as the type of the "},{"code":"body","type":"codeVoice"},{"text":" property:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct AppReducer: ReducerProtocol {","  \/\/ ...","  var body: Reduce<State, Action> {","    FeatureA()","    FeatureB()","    FeatureC()","  }","}"]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reduce","isActive":true},{"type":"text","text":" type is like a type-erased reducer that allows you to construct a reducer from a"},{"text":" ","type":"text"},{"text":"closure. In Swift 5.6, the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerBuilder","isActive":true},{"text":" will automatically erase the reducer you build for","type":"text"},{"type":"text","text":" "},{"text":"you so that you do not have to worry about specifying its type explicitly. This may come with a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"slight performance cost compared to using full opaque types for "},{"type":"codeVoice","code":"body"},{"text":", but should be of comparable","type":"text"},{"text":" ","type":"text"},{"text":"performance to reducers using the ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"type":"text","text":" type, which is now soft-deprecated."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All other features of the library should work in Swift 5.6 without any other changes. This includes"},{"text":" ","type":"text"},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" and all dependency management tools."}]}]}],"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","interfaceLanguage":"swift"},"metadata":{"title":"Migrating to the reducer protocol","modules":[{"name":"ComposableArchitecture"}],"roleHeading":"Article","role":"article"},"schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/AnyReducer/init(_:)-42p1a":{"deprecated":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/init(_:)-42p1a","kind":"symbol","type":"topic","abstract":[],"role":"symbol","url":"\/documentation\/composablearchitecture\/anyreducer\/init(_:)-42p1a","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"text":"<","kind":"text"},{"text":"R","kind":"genericParameter"},{"kind":"text","text":">(("},{"text":"Environment","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"R","kind":"typeIdentifier"},{"kind":"text","text":")"}]},"#Optional-and-pullback-reducers":{"title":"Optional and pullback reducers","url":"#Optional-and-pullback-reducers","titleInlineContent":[{"text":"Optional and pullback reducers","type":"text"}],"type":"link","identifier":"#Optional-and-pullback-reducers"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"title":"ComposableArchitecture","type":"topic","role":"collection","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","url":"\/documentation\/composablearchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"text":" ","type":"text"},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/BindingReducer":{"kind":"symbol","abstract":[{"type":"text","text":"A reducer that updates bindable state when it receives binding actions."}],"navigatorTitle":[{"kind":"identifier","text":"BindingReducer"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/BindingReducer","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"BindingReducer","kind":"identifier"}],"title":"BindingReducer","url":"\/documentation\/composablearchitecture\/bindingreducer","type":"topic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol":{"type":"topic","title":"ReducerProtocol","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"ReducerProtocol","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"A protocol that describes how to evolve the current state of an application to the next state,"},{"type":"text","text":" "},{"type":"text","text":"given an action, and describes what "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectTask"},{"type":"text","text":"s should be executed later by the store, if"},{"text":" ","type":"text"},{"text":"any.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","navigatorTitle":[{"text":"ReducerProtocol","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/reducerprotocol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/environment":{"abstract":[{"type":"text","text":"The current environment."}],"role":"symbol","deprecated":true,"kind":"symbol","title":"environment","fragments":[{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"text":"environment","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Environment","kind":"typeIdentifier"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/environment","url":"\/documentation\/composablearchitecture\/teststore\/environment","type":"topic"},"#Composition-of-features":{"title":"Composition of features","url":"#Composition-of-features","titleInlineContent":[{"text":"Composition of features","type":"text"}],"type":"link","identifier":"#Composition-of-features"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Scope":{"abstract":[{"text":"Embeds a child reducer in a parent domain.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Scope","type":"topic","role":"symbol","title":"Scope","url":"\/documentation\/composablearchitecture\/scope","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Scope"}],"kind":"symbol","navigatorTitle":[{"text":"Scope","kind":"identifier"}]},"#Leaf-node-features":{"title":"Leaf node features","url":"#Leaf-node-features","titleInlineContent":[{"text":"Leaf node features","type":"text"}],"type":"link","identifier":"#Leaf-node-features"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/body-7foai":{"title":"body","type":"topic","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"_Body","type":"codeVoice"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Never"},{"type":"text","text":"."}]},"abstract":[{"type":"text","text":"A non-existent body."}],"kind":"symbol","url":"\/documentation\/composablearchitecture\/reducerprotocol\/body-7foai","role":"symbol","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/body-7foai","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"body","kind":"identifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"Self"},{"text":".","kind":"text"},{"kind":"typeIdentifier","text":"Body","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP4Bodya"}]},"#Embedding-old-reducer-values-in-a-new-reducer-conformance":{"title":"Embedding old reducer values in a new reducer conformance","url":"#Embedding-old-reducer-values-in-a-new-reducer-conformance","titleInlineContent":[{"text":"Embedding old reducer values in a new reducer conformance","type":"text"}],"type":"link","identifier":"#Embedding-old-reducer-values-in-a-new-reducer-conformance"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/forEach(_:action:_:file:fileID:line:)":{"url":"\/documentation\/composablearchitecture\/reducerprotocol\/foreach(_:action:_:file:fileid:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"forEach","kind":"identifier"},{"text":"<","kind":"text"},{"text":"ID","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Element","kind":"genericParameter"},{"text":">(","kind":"text"},{"preciseIdentifier":"s:s15WritableKeyPathC","text":"WritableKeyPath","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa","text":"State"},{"text":", ","kind":"text"},{"preciseIdentifier":"s:21IdentifiedCollections0A5ArrayV","text":"IdentifiedArray","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"ID"},{"text":", ","kind":"text"},{"text":"Element","kind":"typeIdentifier"},{"kind":"text","text":"."},{"text":"State","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa"},{"text":">>, ","kind":"text"},{"text":"action","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"CasePath","preciseIdentifier":"s:9CasePaths0A4PathV"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Action","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa"},{"text":", (","kind":"text"},{"kind":"typeIdentifier","text":"ID"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Element"},{"text":".","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa","text":"Action"},{"kind":"text","text":")>, () -> "},{"kind":"typeIdentifier","text":"Element"},{"kind":"text","text":", "},{"text":"file","kind":"externalParam"},{"kind":"text","text":": "},{"text":"StaticString","preciseIdentifier":"s:s12StaticStringV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"fileID"},{"kind":"text","text":": "},{"preciseIdentifier":"s:s12StaticStringV","text":"StaticString","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"line","kind":"externalParam"},{"kind":"text","text":": "},{"text":"UInt","kind":"typeIdentifier","preciseIdentifier":"s:Su"},{"kind":"text","text":") -> "},{"text":"_ForEachReducer","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"ID","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Element"},{"kind":"text","text":">"}],"type":"topic","abstract":[{"type":"text","text":"Embeds a child reducer in a parent domain that works on elements of a collection in parent"},{"text":" ","type":"text"},{"type":"text","text":"state."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/forEach(_:action:_:file:fileID:line:)","kind":"symbol","title":"forEach(_:action:_:file:fileID:line:)","role":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/MigratingToTheReducerProtocol":{"abstract":[{"type":"text","text":"Learn how to migrate existing applications to use the new "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","type":"reference","isActive":true},{"type":"text","text":", in both Swift 5.7 and"},{"text":" ","type":"text"},{"type":"text","text":"Swift 5.6."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","type":"topic","role":"article","title":"Migrating to the reducer protocol","url":"\/documentation\/composablearchitecture\/migratingtothereducerprotocol","kind":"article"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reduce":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reduce","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Reduce"}],"type":"topic","title":"Reduce","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Reduce","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/reduce","abstract":[{"type":"text","text":"A type-erased reducer that invokes the given "},{"code":"reduce","type":"codeVoice"},{"type":"text","text":" function."}],"role":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/SwiftConcurrency":{"title":"Adopting Swift concurrency","role":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwiftConcurrency","kind":"article","type":"topic","abstract":[{"text":"Learn how to write safe, concurrent effects using Swift’s structured concurrency.","type":"text"}],"url":"\/documentation\/composablearchitecture\/swiftconcurrency"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/AnyReducer/pullback(state:action:environment:)":{"abstract":[{"text":"This API has been soft-deprecated in favor of ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Scope","isActive":true},{"type":"text","text":". Read"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol"},{"text":" for more information.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/pullback(state:action:environment:)","deprecated":true,"type":"topic","role":"symbol","title":"pullback(state:action:environment:)","url":"\/documentation\/composablearchitecture\/anyreducer\/pullback(state:action:environment:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"pullback"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"ParentState"},{"text":", ","kind":"text"},{"text":"ParentAction","kind":"genericParameter"},{"text":", ","kind":"text"},{"kind":"genericParameter","text":"ParentEnvironment"},{"text":">(","kind":"text"},{"text":"state","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:s15WritableKeyPathC","kind":"typeIdentifier","text":"WritableKeyPath"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"ParentState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":">, "},{"text":"action","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"CasePath","preciseIdentifier":"s:9CasePaths0A4PathV"},{"kind":"text","text":"<"},{"text":"ParentAction","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"Action"},{"kind":"text","text":">, "},{"kind":"externalParam","text":"environment"},{"kind":"text","text":": ("},{"text":"ParentEnvironment","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"Environment"},{"kind":"text","text":") -> "},{"text":"AnyReducer","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture10AnyReducerV"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"ParentState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ParentAction"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"ParentEnvironment"},{"kind":"text","text":">"}],"kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/AnyReducer":{"abstract":[{"type":"text","text":"This API has been soft-deprecated in favor of "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true,"type":"reference"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"Read ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","type":"reference","isActive":true},{"text":" for more information.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer","deprecated":true,"type":"topic","role":"symbol","title":"AnyReducer","url":"\/documentation\/composablearchitecture\/anyreducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyReducer"}],"kind":"symbol","navigatorTitle":[{"text":"AnyReducer","kind":"identifier"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/AnyReducer/optional(file:fileID:line:)":{"url":"\/documentation\/composablearchitecture\/anyreducer\/optional(file:fileid:line:)","type":"topic","title":"optional(file:fileID:line:)","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"optional","kind":"identifier"},{"kind":"text","text":"("},{"text":"file","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"fileID"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV","text":"StaticString"},{"text":", ","kind":"text"},{"text":"line","kind":"externalParam"},{"kind":"text","text":": "},{"text":"UInt","preciseIdentifier":"s:Su","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"AnyReducer","preciseIdentifier":"s:22ComposableArchitecture10AnyReducerV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"State","kind":"typeIdentifier"},{"kind":"text","text":"?, "},{"text":"Action","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"Environment"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"This API has been soft-deprecated in favor of"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/ifLet(_:action:then:file:fileID:line:)","isActive":true},{"type":"text","text":". Read"},{"text":" ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","type":"reference","isActive":true},{"type":"text","text":" for more information."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/optional(file:fileID:line:)","deprecated":true},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/ifLet(_:action:then:file:fileID:line:)":{"url":"\/documentation\/composablearchitecture\/reducerprotocol\/iflet(_:action:then:file:fileid:line:)","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"ifLet","kind":"identifier"},{"kind":"text","text":"<"},{"text":"Wrapped","kind":"genericParameter"},{"text":">(","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s15WritableKeyPathC","text":"WritableKeyPath"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa","text":"State"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Wrapped"},{"kind":"text","text":"."},{"preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa","text":"State","kind":"typeIdentifier"},{"kind":"text","text":"?>, "},{"kind":"externalParam","text":"action"},{"text":": ","kind":"text"},{"text":"CasePath","preciseIdentifier":"s:9CasePaths0A4PathV","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Action","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa"},{"kind":"text","text":", "},{"text":"Wrapped","kind":"typeIdentifier"},{"kind":"text","text":"."},{"text":"Action","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa"},{"text":">, ","kind":"text"},{"text":"then","kind":"externalParam"},{"text":": () -> ","kind":"text"},{"text":"Wrapped","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"file"},{"text":": ","kind":"text"},{"text":"StaticString","kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"text":"fileID","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"StaticString","kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV"},{"text":", ","kind":"text"},{"text":"line","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Su","text":"UInt"},{"kind":"text","text":") -> "},{"text":"_IfLetReducer","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Wrapped"},{"text":">","kind":"text"}],"type":"topic","abstract":[{"text":"Embeds a child reducer in a parent domain that works on an optional property of parent state.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/ifLet(_:action:then:file:fileID:line:)","kind":"symbol","title":"ifLet(_:action:then:file:fileID:line:)","role":"symbol"},"#For-each-reducers":{"title":"For-each reducers","url":"#For-each-reducers","titleInlineContent":[{"text":"For-each reducers","type":"text"}],"type":"link","identifier":"#For-each-reducers"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reduce/init(_:environment:)":{"type":"topic","abstract":[],"url":"\/documentation\/composablearchitecture\/reduce\/init(_:environment:)","deprecated":true,"kind":"symbol","title":"init(_:environment:)","role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Environment","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"AnyReducer","preciseIdentifier":"s:22ComposableArchitecture10AnyReducerV","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"State"},{"kind":"text","text":", "},{"text":"Action","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Environment"},{"text":">, ","kind":"text"},{"text":"environment","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Environment","kind":"typeIdentifier"},{"text":")","kind":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reduce\/init(_:environment:)"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/IfLetStore":{"abstract":[{"text":"A view that safely unwraps a store of optional state in order to show one of two views.","type":"text"}],"url":"\/documentation\/composablearchitecture\/ifletstore","type":"topic","navigatorTitle":[{"text":"IfLetStore","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/IfLetStore","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"IfLetStore","kind":"identifier"}],"title":"IfLetStore","kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/ifCaseLet(_:action:then:file:fileID:line:)":{"abstract":[{"type":"text","text":"Embeds a child reducer in a parent domain that works on a case of parent enum state."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/ifCaseLet(_:action:then:file:fileID:line:)","type":"topic","role":"symbol","url":"\/documentation\/composablearchitecture\/reducerprotocol\/ifcaselet(_:action:then:file:fileid:line:)","title":"ifCaseLet(_:action:then:file:fileID:line:)","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"ifCaseLet"},{"text":"<","kind":"text"},{"text":"Case","kind":"genericParameter"},{"kind":"text","text":">("},{"preciseIdentifier":"s:9CasePaths0A4PathV","kind":"typeIdentifier","text":"CasePath"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"text":".","kind":"text"},{"text":"State","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Case"},{"text":".","kind":"text"},{"text":"State","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa"},{"kind":"text","text":">, "},{"kind":"externalParam","text":"action"},{"kind":"text","text":": "},{"text":"CasePath","kind":"typeIdentifier","preciseIdentifier":"s:9CasePaths0A4PathV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Action","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa"},{"text":", ","kind":"text"},{"text":"Case","kind":"typeIdentifier"},{"text":".","kind":"text"},{"preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa","kind":"typeIdentifier","text":"Action"},{"text":">, ","kind":"text"},{"kind":"externalParam","text":"then"},{"kind":"text","text":": () -> "},{"text":"Case","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"file","kind":"externalParam"},{"kind":"text","text":": "},{"text":"StaticString","kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"fileID"},{"text":": ","kind":"text"},{"text":"StaticString","preciseIdentifier":"s:s12StaticStringV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"line","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:Su","text":"UInt"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"_IfCaseLetReducer"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"Case","kind":"typeIdentifier"},{"kind":"text","text":">"}],"kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/reduce(into:action:)-8yinq":{"role":"symbol","abstract":[{"type":"text","text":"Evolves the current state of the reducer to the next state."}],"kind":"symbol","url":"\/documentation\/composablearchitecture\/reducerprotocol\/reduce(into:action:)-8yinq","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"reduce","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"into"},{"text":": ","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":"."},{"text":"State","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP5StateQa","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"action"},{"kind":"text","text":": "},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":"."},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa","text":"Action"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture10EffectTaska","text":"EffectTask"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"text":"Action","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15ReducerProtocolP6ActionQa"},{"kind":"text","text":">"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/reduce(into:action:)-8yinq","required":true,"type":"topic","title":"reduce(into:action:)","defaultImplementations":1},"#Testing":{"title":"Testing","url":"#Testing","titleInlineContent":[{"text":"Testing","type":"text"}],"type":"link","identifier":"#Testing"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerBuilder":{"abstract":[{"type":"text","text":"A result builder for combining reducers into a single reducer by running each, one after the"},{"type":"text","text":" "},{"text":"other, and returning their merged effects.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerBuilder","type":"topic","role":"symbol","title":"ReducerBuilder","url":"\/documentation\/composablearchitecture\/reducerbuilder","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ReducerBuilder"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ReducerBuilder"}]},"#Dependencies":{"title":"Dependencies","url":"#Dependencies","titleInlineContent":[{"text":"Dependencies","type":"text"}],"type":"link","identifier":"#Dependencies"},"#Migration-using-Swift-56":{"title":"Migration using Swift 5.6","url":"#Migration-using-Swift-56","titleInlineContent":[{"text":"Migration using Swift 5.6","type":"text"}],"type":"link","identifier":"#Migration-using-Swift-56"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","kind":"symbol","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"type":"topic","title":"Reducer","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/reducer","abstract":[{"type":"text","text":"This API has been deprecated in favor of "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Read "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","isActive":true},{"text":" for more information.","type":"text"}],"deprecated":true,"role":"symbol"},"#Stores":{"title":"Stores","url":"#Stores","titleInlineContent":[{"text":"Stores","type":"text"}],"type":"link","identifier":"#Stores"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/AnyReducer/forEach(state:action:environment:file:fileID:line:)-2ypoa":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/AnyReducer\/forEach(state:action:environment:file:fileID:line:)-2ypoa","url":"\/documentation\/composablearchitecture\/anyreducer\/foreach(state:action:environment:file:fileid:line:)-2ypoa","type":"topic","title":"forEach(state:action:environment:file:fileID:line:)","role":"symbol","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"forEach"},{"text":"<","kind":"text"},{"text":"ParentState","kind":"genericParameter"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"ParentAction"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"ParentEnvironment"},{"kind":"text","text":", "},{"text":"ID","kind":"genericParameter"},{"kind":"text","text":">("},{"kind":"externalParam","text":"state"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:s15WritableKeyPathC","text":"WritableKeyPath"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"ParentState"},{"kind":"text","text":", "},{"preciseIdentifier":"s:21IdentifiedCollections0A5ArrayV","kind":"typeIdentifier","text":"IdentifiedArray"},{"text":"<","kind":"text"},{"text":"ID","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"State","kind":"typeIdentifier"},{"kind":"text","text":">>, "},{"kind":"externalParam","text":"action"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"CasePath","preciseIdentifier":"s:9CasePaths0A4PathV"},{"text":"<","kind":"text"},{"text":"ParentAction","kind":"typeIdentifier"},{"text":", (","kind":"text"},{"text":"ID","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"Action","kind":"typeIdentifier"},{"kind":"text","text":")>, "},{"kind":"externalParam","text":"environment"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"ParentEnvironment"},{"kind":"text","text":") -> "},{"text":"Environment","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"file","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:s12StaticStringV","text":"StaticString","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"fileID"},{"text":": ","kind":"text"},{"text":"StaticString","kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV"},{"text":", ","kind":"text"},{"text":"line","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"UInt","kind":"typeIdentifier","preciseIdentifier":"s:Su"},{"kind":"text","text":") -> "},{"text":"AnyReducer","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture10AnyReducerV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"ParentState"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"ParentAction"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"ParentEnvironment"},{"text":">","kind":"text"}],"deprecated":true,"abstract":[{"type":"text","text":"This API has been soft-deprecated in favor of"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/forEach(_:action:_:file:fileID:line:)"},{"type":"text","text":". Read"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","isActive":true,"type":"reference"},{"text":" for more information.","type":"text"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/EffectTask":{"kind":"symbol","abstract":[{"type":"text","text":"A convenience type alias for referring to an effect that can never fail, like the kind of"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectPublisher"},{"type":"text","text":" returned by a reducer after processing an action."}],"navigatorTitle":[{"text":"EffectTask","kind":"identifier"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectTask","role":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"text":" ","kind":"text"},{"text":"EffectTask","kind":"identifier"}],"title":"EffectTask","url":"\/documentation\/composablearchitecture\/effecttask","type":"topic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/dependencies":{"abstract":[{"text":"The current dependencies of the test store.","type":"text"}],"fragments":[{"kind":"keyword","text":"var"},{"text":" ","kind":"text"},{"kind":"identifier","text":"dependencies"},{"kind":"text","text":": "},{"preciseIdentifier":"s:12Dependencies16DependencyValuesV","kind":"typeIdentifier","text":"DependencyValues"}],"url":"\/documentation\/composablearchitecture\/teststore\/dependencies","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/dependencies","title":"dependencies","kind":"symbol","type":"topic","role":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/StoreOf":{"url":"\/documentation\/composablearchitecture\/storeof","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"StoreOf"}],"kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"A convenience type alias for referring to a store of a given reducer’s domain."}],"title":"StoreOf","navigatorTitle":[{"kind":"identifier","text":"StoreOf"}],"type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/StoreOf"},"#Binding-reducers":{"title":"Binding reducers","url":"#Binding-reducers","titleInlineContent":[{"text":"Binding reducers","type":"text"}],"type":"link","identifier":"#Binding-reducers"}}}