{"schemaVersion":{"patch":0,"major":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"text":" ","type":"text"},{"type":"text","text":"Architecture."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"},"sections":[],"kind":"article","metadata":{"roleHeading":"Article","modules":[{"name":"ComposableArchitecture"}],"title":"Testing","role":"article"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The testability of features built in the Composable Architecture is the #1 priority of the library."},{"type":"text","text":" "},{"type":"text","text":"It should be possible to test not only how state changes when actions are sent into the store,"},{"type":"text","text":" "},{"type":"text","text":"but also how effects are executed and feed data back into the system."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"#Testing-state-changes","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"#Testing-effects","type":"reference","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"#Non-exhaustive-testing","type":"reference"}]}]}]},{"text":"Testing state changes","type":"heading","level":2,"anchor":"Testing-state-changes"},{"inlineContent":[{"type":"text","text":"State changes are by far the simplest thing to test in features built with the library. A"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"type":"text","text":"’s first responsibility is to mutate the current state based on the action received into"},{"type":"text","text":" "},{"type":"text","text":"the system. To test this we can technically run a piece of mutable state through the reducer and"},{"type":"text","text":" "},{"text":"then assert on how it changed after, like this:","type":"text"}],"type":"paragraph"},{"code":["struct Feature: ReducerProtocol {","  struct State: Equatable { var count = 0 }","  enum Action { case incrementButtonTapped, decrementButtonTapped }","","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    switch action {","    case .incrementButtonTapped:","      state.count += 1","      return .none","    case .decrementButtonTapped:","      state.count -= 1","      return .none","    }","  }","}","","func testBasics() {","  let feature = Feature()","  var currentState = Feature.State(count: 0)","  _ = feature.reduce(into: &currentState, action: .incrementButtonTapped)","  XCTAssertEqual(","    currentState,","    State(count: 1)","  )","","  _ = feature.reduce(into: &currentState, action: .decrementButtonTapped)","  XCTAssertEqual(","    currentState,","    State(count: 0)","  )","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This will technically work, but it’s a lot boilerplate for something that should be quite simple.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The library comes with a tool specifically designed to make testing like this much simpler and more","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"concise. It’s called "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":", and it is constructed similarly to "},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","type":"reference"},{"type":"text","text":" by providing the"},{"text":" ","type":"text"},{"text":"initial state of the feature and the ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"text":" that run’s the feature’s logic:","type":"text"}]},{"code":["@MainActor","class CounterTests: XCTestCase {","  func testBasics() async {","    let store = TestStore(","      initialState: Feature.State(count: 0),","      reducer: Feature()","    )","  }","}"],"type":"codeListing","syntax":"swift"},{"content":[{"inlineContent":[{"type":"text","text":"Test cases that use "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"reference","isActive":true},{"text":" should be annotated as ","type":"text"},{"type":"codeVoice","code":"@MainActor"},{"text":" and test methods should","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"be marked as "},{"type":"codeVoice","code":"async"},{"type":"text","text":" since most assertion helpers on "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":" can suspend."}],"type":"paragraph"}],"name":"Tip","type":"aside","style":"tip"},{"type":"paragraph","inlineContent":[{"text":"Test stores have a ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61","isActive":true},{"text":" method, but it behaves differently","type":"text"},{"type":"text","text":" "},{"type":"text","text":"from stores and view stores. You provide an action to send into the system, but then you must also"},{"type":"text","text":" "},{"text":"provide a trailing closure to describe how the state of the feature changed after sending the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"action:"}]},{"code":["await store.send(.incrementButtonTapped) {","  …","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This closure is handed a mutable variable that represents the state of the feature ","type":"text"},{"inlineContent":[{"text":"before","type":"text"}],"type":"emphasis"},{"text":" sending","type":"text"},{"type":"text","text":" "},{"text":"the action, and it is your job to make the appropriate mutations to it to get it into the shape","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it should be after sending the action:"}]},{"code":["await store.send(.incrementButtonTapped) {","  $0.count = 1","}"],"type":"codeListing","syntax":"swift"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":"The "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61","isActive":true,"type":"reference"},{"type":"text","text":" method is "},{"type":"codeVoice","code":"async"},{"text":" for technical reasons that we","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"do not have to worry about right now."}],"type":"paragraph"}],"type":"aside","name":"Note"},{"inlineContent":[{"type":"text","text":"If your mutation is incorrect, meaning you perform a mutation that is different from what happened"},{"text":" ","type":"text"},{"text":"in the ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"type":"text","text":", then you will get a test failure with a nicely formatted message showing exactly"},{"type":"text","text":" "},{"text":"what part of the state does not match:","type":"text"}],"type":"paragraph"},{"code":["await store.send(.incrementButtonTapped) {","  $0.count = 999","}"],"syntax":"swift","type":"codeListing"},{"type":"codeListing","syntax":null,"code":["🛑 testSomething(): A state change does not match expectation: …","","  − TestStoreTests.State(count: 999)","  + TestStoreTests.State(count: 1)","","(Expected: −, Actual: +)"]},{"type":"paragraph","inlineContent":[{"text":"You can also send multiple actions to emulate a script of user actions and assert each step of the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"way how the state evolved:"}]},{"syntax":"swift","type":"codeListing","code":["await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.incrementButtonTapped) {","  $0.count = 2","}","await store.send(.decrementButtonTapped) {","  $0.count = 1","}"]},{"type":"aside","style":"tip","name":"Tip","content":[{"type":"paragraph","inlineContent":[{"text":"Technically we could have written the mutation block in the following manner:","type":"text"}]},{"code":["await store.send(.incrementButtonTapped) {","  $0.count += 1","}","await store.send(.decrementButtonTapped) {","  $0.count -= 1","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"…and the test would have still passed."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, this does not produce as strong of an assertion. It shows that the count did increment"},{"text":" ","type":"text"},{"type":"text","text":"by one, but we haven’t proven we know the precise value of "},{"type":"codeVoice","code":"count"},{"type":"text","text":" at each step of the way."}],"type":"paragraph"},{"inlineContent":[{"text":"In general, the less logic you have in the trailing closure of","type":"text"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61","type":"reference","isActive":true},{"type":"text","text":", the stronger your assertion will be. It is best to"},{"text":" ","type":"text"},{"text":"use simple, hard-coded data for the mutation.","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test stores do expose a "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state","isActive":true,"type":"reference"},{"type":"text","text":" property, which can be useful for performing assertions"},{"text":" ","type":"text"},{"type":"text","text":"on computed properties you might have defined on your state. For example, if "},{"code":"State","type":"codeVoice"},{"text":" had a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"computed property for checking if "},{"type":"codeVoice","code":"count"},{"text":" was prime, we could test it like so:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["store.send(.incrementButtonTapped) {","  $0.count = 3","}","XCTAssertTrue(store.state.isPrime)"]},{"type":"paragraph","inlineContent":[{"text":"However, when inside the trailing closure of ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61"},{"type":"text","text":", the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state"},{"type":"text","text":" property is equal to the state "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"text":" sending the action, not after. That","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"prevents you from being able to use an escape hatch to get around needing to actually describe the"},{"type":"text","text":" "},{"type":"text","text":"state mutation, like so:"}]},{"code":["store.send(.incrementButtonTapped) {","  $0 = store.state \/\/ 🛑 store.state is the previous state, not new state.","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Testing effects","type":"heading","anchor":"Testing-effects"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Testing state mutations as shown in the previous section is powerful, but is only half the story"},{"text":" ","type":"text"},{"type":"text","text":"when it comes to testing features built in the Composable Architecture. The second responsibility of"},{"text":" ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"text":"s, after mutating state from an action, is to return an ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectTask","isActive":true,"type":"reference"},{"type":"text","text":" that encapsulates"},{"type":"text","text":" "},{"text":"a unit of work that runs in the outside world and feeds data back into the system.","type":"text"}]},{"inlineContent":[{"text":"Effects form a major part of a feature’s logic. They can perform network requests to external","type":"text"},{"type":"text","text":" "},{"type":"text","text":"services, load and save data to disk, start and stop timers, interact with Apple frameworks (Core"},{"type":"text","text":" "},{"type":"text","text":"Location, Core Motion, Speech Recognition, etc.), and more."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As a simple example, suppose we have a feature with a button such that when you tap it, it starts"},{"type":"text","text":" "},{"text":"a timer that counts up until you reach 5, and then stops. This can be accomplished using the","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectPublisher\/run(priority:operation:catch:file:fileID:line:)"},{"text":" helper on ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectTask","isActive":true},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which provides you with an asynchronous context to operate in and can send multiple actions back","type":"text"},{"type":"text","text":" "},{"type":"text","text":"into the system:"}]},{"syntax":"swift","type":"codeListing","code":["struct Feature: ReducerProtocol {","  struct State: Equatable { var count = 0 }","  enum Action { case startTimerButtonTapped, timerTick }","  enum TimerID {}","","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    switch action {","    case .startTimerButtonTapped:","      state.count = 0","      return .run { send in","        for _ in 1...5 {","          try await Task.sleep(for: .seconds(1))","          await send(.timerTick)","        }","      }","","    case .timerTick:","      state.count += 1","      return .none","    }","  }","}"]},{"inlineContent":[{"type":"text","text":"To test this we can start off similar to how we did in the "},{"overridingTitle":"previous section","type":"reference","identifier":"#Testing-state-changes","isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"previous section"}]},{"type":"text","text":" "},{"text":"when testing state mutations:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["@MainActor","class TimerTests: XCTestCase {","  func testBasics() async {","    let store = TestStore(","      initialState: Feature.State(count: 0),","      reducer: Feature()","    )","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"With the basics set up, we can send an action into the system to assert on what happens, such as the"},{"text":" ","type":"text"},{"code":".startTimerButtonTapped","type":"codeVoice"},{"type":"text","text":" action. This time we don’t actually expect state to change at first"},{"type":"text","text":" "},{"type":"text","text":"because when starting the timer we don’t change state, and so in this case we can leave off the"},{"text":" ","type":"text"},{"type":"text","text":"trailer closure:"}]},{"syntax":"swift","code":["await store.send(.startTimerButtonTapped)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if we run the test as-is with no further interactions with the test store, we get a"},{"type":"text","text":" "},{"type":"text","text":"failure:"}]},{"type":"codeListing","syntax":null,"code":["🛑 testSomething(): An effect returned for this action is still running.","   It must complete before the end of the test. …"]},{"inlineContent":[{"text":"This is happening because ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","isActive":true},{"type":"text","text":" requires you to exhaustively prove how the entire system"},{"type":"text","text":" "},{"type":"text","text":"of your feature evolves over time. If an effect is still running when the test finishes and the"},{"type":"text","text":" "},{"type":"text","text":"test store did "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" fail then it could be hiding potential bugs. Perhaps the effect is not"},{"type":"text","text":" "},{"text":"supposed to be running, or perhaps the data it feeds into the system later is wrong. The test store","type":"text"},{"type":"text","text":" "},{"text":"requires all effects to finish.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To get this test passing we need to assert on the actions that are sent back into the system","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by the effect. We do this by using the "},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd","type":"reference"},{"text":" ","type":"text"},{"text":"method, which allows you to assert which action you expect to receive from an effect, as well as how","type":"text"},{"type":"text","text":" "},{"text":"the state changes after receiving that effect:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["await store.receive(.timerTick) {","  $0.count = 1","}"]},{"type":"paragraph","inlineContent":[{"text":"However, if we run this test we still get a failure because we asserted a ","type":"text"},{"type":"codeVoice","code":"timerTick"},{"text":" action was","type":"text"},{"text":" ","type":"text"},{"text":"going to be received, but after waiting around for a small amount of time no action was received:","type":"text"}]},{"code":["🛑 testSomething(): Expected to receive an action, but received none after 0.1 seconds."],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is because our timer is on a 1 second interval, and by default"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd"},{"type":"text","text":" only waits for a fraction of a second. This"},{"text":" ","type":"text"},{"type":"text","text":"is because typically you should not be performing real time-based asynchrony in effects, and instead"},{"type":"text","text":" "},{"type":"text","text":"using a controlled entity, such as a clock, that can be sped up in tests. We will demonstrate this"},{"text":" ","type":"text"},{"text":"in a moment, so for now let’s increase the timeout:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["await store.receive(.timerTick, timeout: .seconds(2)) {","  $0.count = 1","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This assertion now passes, but the overall test is still failing because there are still more"},{"type":"text","text":" "},{"type":"text","text":"actions to receive. The timer should tick 5 times in total, so we need five "},{"type":"codeVoice","code":"receive"},{"type":"text","text":" assertions:"}]},{"syntax":"swift","code":["await store.receive(.timerTick, timeout: .seconds(2)) {","  $0.count = 1","}","await store.receive(.timerTick, timeout: .seconds(2)) {","  $0.count = 2","}","await store.receive(.timerTick, timeout: .seconds(2)) {","  $0.count = 3","}","await store.receive(.timerTick, timeout: .seconds(2)) {","  $0.count = 4","}","await store.receive(.timerTick, timeout: .seconds(2)) {","  $0.count = 5","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Now the full test suite passes, and we have exhaustively proven how effects are executed in this","type":"text"},{"type":"text","text":" "},{"type":"text","text":"feature. If in the future we tweak the logic of the effect, like say have it emit 10 times instead"},{"type":"text","text":" "},{"text":"of 5, then we will immediately get a test failure letting us know that we have not properly","type":"text"},{"type":"text","text":" "},{"type":"text","text":"asserted on how the features evolve over time."}]},{"inlineContent":[{"text":"However, there is something not ideal about how this feature is structured, and that is the fact","type":"text"},{"text":" ","type":"text"},{"text":"that we are doing actual, uncontrolled time-based asynchrony in the effect:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["return .run { send in","  for _ in 1...5 {","    try await Task.sleep(for: .seconds(1)) \/\/ ⬅️","    await send(.timerTick)","  }","}"],"syntax":"swift"},{"inlineContent":[{"text":"This means for our test to run we must actually wait for 5 real world seconds to pass so that we","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can receive all of the actions from the timer. This makes our test suite far too slow. What if in"},{"text":" ","type":"text"},{"type":"text","text":"the future we need to test a feature that has a timer that emits hundreds or thousands of times?"},{"text":" ","type":"text"},{"text":"We cannot hold up our test suite for minutes or hours just to test that one feature.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To fix this we need to add a dependency to the reducer that aids in performing time-based"},{"text":" ","type":"text"},{"type":"text","text":"asynchrony, but in a way that is controllable. One way to do this is to add a clock as a"},{"type":"text","text":" "},{"code":"@Dependency","type":"codeVoice"},{"text":" to the reducer:","type":"text"}]},{"syntax":"swift","code":["import Clocks","","struct Feature: ReducerProtocol {","  struct State { … }","  enum Action { … }","  @Dependency(\\.continuousClock) var clock","}"],"type":"codeListing"},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"text":"To make use of controllable clocks you must use the ","type":"text"},{"isActive":true,"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/swift-clocks"},{"text":" library, which is","type":"text"},{"text":" ","type":"text"},{"text":"automatically included with the Composable Architecture.","type":"text"}]}],"name":"Tip","type":"aside"},{"inlineContent":[{"type":"text","text":"And then the timer effect in the reducer can make use of the clock to sleep rather than reaching"},{"type":"text","text":" "},{"type":"text","text":"out to the uncontrollable "},{"code":"Task.sleep","type":"codeVoice"},{"type":"text","text":" method:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["return .run { send in","  for _ in 1...5 {","    try await self.clock.sleep(for: .seconds(1))","    await send(.timerTick)","  }","}"]},{"content":[{"inlineContent":[{"type":"text","text":"The "},{"code":"sleep(for:)","type":"codeVoice"},{"type":"text","text":" method on "},{"type":"codeVoice","code":"Clock"},{"type":"text","text":" is provided by the"},{"type":"text","text":" "},{"isActive":true,"overridingTitle":"Swift Clocks","overridingTitleInlineContent":[{"type":"text","text":"Swift Clocks"}],"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/swift-clocks"},{"text":" library.","type":"text"}],"type":"paragraph"}],"style":"tip","name":"Tip","type":"aside"},{"type":"paragraph","inlineContent":[{"text":"By having a clock as a dependency in the feature we can supply a controlled version in tests, such","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as an immediate clock that does not suspend at all when you ask it to sleep:"}]},{"syntax":"swift","type":"codeListing","code":["let store = TestStore(","  initialState: Feature.State(count: 0),","  reducer: Feature()",")","","store.dependencies.continuousClock = ImmediateClock()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With that small change we can drop the "},{"type":"codeVoice","code":"timeout"},{"type":"text","text":" arguments from the"},{"type":"text","text":" "},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd","type":"reference"},{"type":"text","text":" invocations:"}]},{"syntax":"swift","type":"codeListing","code":["await store.receive(.timerTick) {","  $0.count = 1","}","await store.receive(.timerTick) {","  $0.count = 2","}","await store.receive(.timerTick) {","  $0.count = 3","}","await store.receive(.timerTick) {","  $0.count = 4","}","await store.receive(.timerTick) {","  $0.count = 5","}"]},{"inlineContent":[{"type":"text","text":"…and the test still passes, but now does so immediately."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The more time you take to control the dependencies your features use, the easier it will be to"},{"type":"text","text":" "},{"type":"text","text":"write tests for your features. To learn more about designing dependencies and how to best leverage"},{"type":"text","text":" "},{"text":"dependencies, read the ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement"},{"text":" article.","type":"text"}],"type":"paragraph"},{"level":2,"type":"heading","text":"Non-exhaustive testing","anchor":"Non-exhaustive-testing"},{"inlineContent":[{"text":"The previous sections describe in detail how to write tests in the Composable Architecture that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"exhaustively prove how the entire feature evolves over time. You must assert on how every piece"},{"text":" ","type":"text"},{"type":"text","text":"of state changes, how every effect feeds data back into the system, and you must even make sure"},{"text":" ","type":"text"},{"text":"that all effects complete before the test store is deallocated. This can be powerful, but it can","type":"text"},{"type":"text","text":" "},{"type":"text","text":"also be a nuisance, especially for highly composed features. This is why sometimes you may want"},{"type":"text","text":" "},{"type":"text","text":"to test in a non-exhaustive style."}],"type":"paragraph"},{"style":"tip","type":"aside","name":"Tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The concept of “non-exhaustive test store” was first introduced by"},{"text":" ","type":"text"},{"identifier":"https:\/\/www.merowing.info","isActive":true,"type":"reference"},{"type":"text","text":" in a "},{"identifier":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/","isActive":true,"type":"reference"},{"text":" and","type":"text"},{"type":"text","text":" "},{"identifier":"https:\/\/vimeo.com\/751173570","type":"reference","isActive":true},{"type":"text","text":", and then later became integrated into the"},{"text":" ","type":"text"},{"type":"text","text":"core library."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This style of testing is most useful for testing the integration of multiple features where you want"},{"text":" ","type":"text"},{"text":"to focus on just a certain slice of the behavior. Exhaustive testing can still be important to use","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for leaf node features, where you truly do want to assert on everything happening inside the"},{"text":" ","type":"text"},{"type":"text","text":"feature."}]},{"inlineContent":[{"text":"For example, suppose you have a tab-based application where the 3rd tab is a login screen. The user","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can fill in some data on the screen, then tap the “Submit” button, and then a series of events"},{"text":" ","type":"text"},{"type":"text","text":"happens to  log the user in. Once the user is logged in, the 3rd tab switches from a login screen"},{"text":" ","type":"text"},{"type":"text","text":"to a profile screen, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"text":" the selected tab switches to the first tab, which is an activity screen.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When writing tests for the login feature we will want to do that in the exhaustive style so that we","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can prove exactly how the feature would behave in production. But, suppose we wanted to write an"},{"text":" ","type":"text"},{"type":"text","text":"integration test that proves after the user taps the “Login” button that ultimately the selected"},{"text":" ","type":"text"},{"type":"text","text":"tab switches to the first tab."}]},{"type":"paragraph","inlineContent":[{"text":"In order to test such a complex flow we must test the integration of multiple features, which means","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"dealing with complex, nested state and effects. We can emulate this flow in a test by sending"},{"text":" ","type":"text"},{"type":"text","text":"actions that mimic the user logging in, and then eventually assert that the selected tab switched"},{"type":"text","text":" "},{"type":"text","text":"to activity:"}]},{"syntax":"swift","type":"codeListing","code":["let store = TestStore(","  initialState: App.State(),","  reducer: App()",")","","\/\/ 1️⃣ Emulate user tapping on submit button.","await store.send(.login(.submitButtonTapped)) {","  \/\/ 2️⃣ Assert how all state changes in the login feature","  $0.login?.isLoading = true","  …","}","","\/\/ 3️⃣ Login feature performs API request to login, and","\/\/    sends response back into system.","await store.receive(.login(.loginResponse(.success))) {","\/\/ 4️⃣ Assert how all state changes in the login feature","  $0.login?.isLoading = false","  …","}","","\/\/ 5️⃣ Login feature sends a delegate action to let parent","\/\/    feature know it has successfully logged in.","await store.receive(.login(.delegate(.didLogin))) {","\/\/ 6️⃣ Assert how all of app state changes due to that action.","  $0.authenticatedTab = .loggedIn(","    Profile.State(...)","  )","  …","  \/\/ 7️⃣ *Finally* assert that the selected tab switches to activity.","  $0.selectedTab = .activity","}"]},{"type":"paragraph","inlineContent":[{"text":"Doing this with exhaustive testing is verbose, and there are a few problems with this:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"We need to be intimately knowledgeable in how the login feature works so that we can assert"},{"type":"text","text":" "},{"type":"text","text":"on how its state changes and how its effects feed data back into the system."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the login feature were to change its logic we may get test failures here even though the logic"},{"type":"text","text":" "},{"text":"we are acutally trying to test doesn’t really care about those changes.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"This test is very long, and so if there are other similar but slightly different flows we want to","type":"text"},{"type":"text","text":" "},{"text":"test we will be tempted to copy-and-paste the whole thing, leading to lots of duplicated, fragile","type":"text"},{"type":"text","text":" "},{"text":"tests.","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Non-exhaustive testing allows us to test the high-level flow that we are concerned with, that of"},{"type":"text","text":" "},{"text":"login causing the selected tab to switch to activity, without having to worry about what is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"happening inside the login feature. To do this, we can turn off "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","isActive":true},{"type":"text","text":" in the"},{"text":" ","type":"text"},{"text":"test store, and then just assert on what we are interested in:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let store = TestStore(","  initialState: App.State(),","  reducer: App()",")","store.exhaustivity = .off \/\/ ⬅️","","await store.send(.login(.submitButtonTapped))","await store.receive(.login(.delegate(.didLogin))) {","  $0.selectedTab = .activity","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"In particular, we did not assert on how the login’s state changed or how the login’s effects fed"},{"type":"text","text":" "},{"type":"text","text":"data back into the system. We just assert that when the “Submit” button is tapped that eventually"},{"type":"text","text":" "},{"type":"text","text":"we get the "},{"code":"didLogin","type":"codeVoice"},{"type":"text","text":" delegate action and that causes the selected tab to flip to activity. Now"},{"text":" ","type":"text"},{"type":"text","text":"the login feature is free to make any change it wants to make without affecting this integration"},{"text":" ","type":"text"},{"type":"text","text":"test."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Using ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off","isActive":true,"type":"reference"},{"type":"text","text":" for "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","isActive":true},{"text":" causes all un-asserted changes to pass","type":"text"},{"type":"text","text":" "},{"type":"text","text":"without any notification. If you would like to see what test failures are being suppressed without"},{"text":" ","type":"text"},{"text":"actually causing a failure, you can use ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)","type":"reference","isActive":true},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let store = TestStore(","  initialState: App.State(),","  reducer: App()",")","store.exhaustivity = .off(showSkippedAssertions: true) \/\/ ⬅️","","await store.send(.login(.submitButtonTapped))","await store.receive(.login(.delegate(.didLogin))) {","  $0.selectedTab = .activity","}"]},{"inlineContent":[{"text":"When this is run you will get grey, informational boxes on each assertion where some change wasn’t","type":"text"},{"type":"text","text":" "},{"type":"text","text":"fully asserted on:"}],"type":"paragraph"},{"code":["◽️ A state change does not match expectation: …","","     App.State(","       authenticatedTab: .loggedOut(","         Login.State(","   −       isLoading: false","   +       isLoading: true,","           …","         )","       )","     )","   ","   (Expected: −, Actual: +)","","◽️ Skipped receiving .login(.loginResponse(.success))","","◽️ A state change does not match expectation: …","","     App.State(","   −   authenticatedTab: .loggedOut(…)","   +   authenticatedTab: .loggedIn(","   +     Profile.State(…)","   +   ),","       …","     )","   ","   (Expected: −, Actual: +)"],"syntax":null,"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The test still passes, and none of these notifications are test failures. They just let you know","type":"text"},{"type":"text","text":" "},{"text":"what things you are not explicitly asserting against, and can be useful to see when tracking down","type":"text"},{"type":"text","text":" "},{"text":"bugs that happen in production but that aren’t currently detected in tests.","type":"text"}]}]}],"variants":[{"paths":["\/documentation\/composablearchitecture\/testing"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"https://www.merowing.info":{"url":"https:\/\/www.merowing.info","title":"Krzysztof Zabłocki","identifier":"https:\/\/www.merowing.info","titleInlineContent":[{"text":"Krzysztof Zabłocki","type":"text"}],"type":"link"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/EffectPublisher":{"title":"EffectPublisher","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectPublisher","abstract":[{"type":"text","text":"A type that encapsulates a unit of work that can be run in the outside world, and can feed"},{"type":"text","text":" "},{"type":"text","text":"actions back to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"text":".","type":"text"}],"role":"symbol","url":"\/documentation\/composablearchitecture\/effectpublisher","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"EffectPublisher"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EffectPublisher"}]},"https://www.merowing.info/exhaustive-testing-in-tca/":{"url":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/","title":"blog post","identifier":"https:\/\/www.merowing.info\/exhaustive-testing-in-tca\/","titleInlineContent":[{"text":"blog post","type":"text"}],"type":"link"},"#Testing-effects":{"url":"#Testing-effects","title":"Testing effects","identifier":"#Testing-effects","titleInlineContent":[{"text":"Testing effects","type":"text"}],"type":"link"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","kind":"symbol","navigatorTitle":[{"text":"Reducer","kind":"identifier"}],"type":"topic","title":"Reducer","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/reducer","abstract":[{"type":"text","text":"This API has been deprecated in favor of "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Read "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","isActive":true},{"text":" for more information.","type":"text"}],"deprecated":true,"role":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"title":"ComposableArchitecture","type":"topic","role":"collection","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","url":"\/documentation\/composablearchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"text":" ","type":"text"},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"kind":"symbol"},"#Non-exhaustive-testing":{"url":"#Non-exhaustive-testing","title":"Non-exhaustive testing","identifier":"#Non-exhaustive-testing","titleInlineContent":[{"text":"Non-exhaustive testing","type":"text"}],"type":"link"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Exhaustivity/off":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off","title":"off","url":"\/documentation\/composablearchitecture\/exhaustivity\/off","type":"topic","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"kind":"keyword","text":"let"},{"text":" ","kind":"text"},{"kind":"identifier","text":"off"},{"kind":"text","text":": "},{"preciseIdentifier":"s:22ComposableArchitecture12ExhaustivityO","kind":"typeIdentifier","text":"Exhaustivity"}],"abstract":[{"type":"text","text":"Non-exhaustive assertions."}],"role":"symbol","kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/EffectTask":{"kind":"symbol","abstract":[{"type":"text","text":"A convenience type alias for referring to an effect that can never fail, like the kind of"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectPublisher"},{"type":"text","text":" returned by a reducer after processing an action."}],"navigatorTitle":[{"text":"EffectTask","kind":"identifier"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectTask","role":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"text":" ","kind":"text"},{"text":"EffectTask","kind":"identifier"}],"title":"EffectTask","url":"\/documentation\/composablearchitecture\/effecttask","type":"topic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/send(_:assert:file:line:)-1ax61":{"fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"send"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"ScopedAction"},{"kind":"text","text":", "},{"kind":"externalParam","text":"assert"},{"text":": ((","kind":"text"},{"kind":"keyword","text":"inout"},{"text":" ","kind":"text"},{"kind":"typeIdentifier","text":"ScopedState"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"preciseIdentifier":"s:s4Voida","kind":"typeIdentifier","text":"Void"},{"text":")?, ","kind":"text"},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV","text":"StaticString"},{"kind":"text","text":", "},{"text":"line","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"TestStoreTask","preciseIdentifier":"s:22ComposableArchitecture13TestStoreTaskV"}],"kind":"symbol","abstract":[{"text":"Sends an action to the store and asserts when state changes.","type":"text"}],"type":"topic","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"constraints":[{"type":"codeVoice","code":"ScopedState"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"title":"send(_:assert:file:line:)","role":"symbol","url":"\/documentation\/composablearchitecture\/teststore\/send(_:assert:file:line:)-1ax61","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/send(_:assert:file:line:)-1ax61"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/state":{"fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"state"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"State"}],"kind":"symbol","abstract":[{"type":"text","text":"The current state of the test store."}],"type":"topic","title":"state","role":"symbol","url":"\/documentation\/composablearchitecture\/teststore\/state","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/state"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Store":{"title":"Store","abstract":[{"text":"A store represents the runtime that powers the application. It is the object that you will pass","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"around to views that need to interact with the application."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"navigatorTitle":[{"kind":"identifier","text":"Store"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","role":"symbol","url":"\/documentation\/composablearchitecture\/store","type":"topic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyManagement":{"title":"Dependencies","role":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","kind":"article","type":"topic","abstract":[{"text":"Learn how to register dependencies with the library so that they can be immediately accessible from","type":"text"},{"text":" ","type":"text"},{"text":"any reducer.","type":"text"}],"url":"\/documentation\/composablearchitecture\/dependencymanagement"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol":{"type":"topic","title":"ReducerProtocol","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"ReducerProtocol","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"A protocol that describes how to evolve the current state of an application to the next state,"},{"type":"text","text":" "},{"type":"text","text":"given an action, and describes what "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectTask"},{"type":"text","text":"s should be executed later by the store, if"},{"text":" ","type":"text"},{"text":"any.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","navigatorTitle":[{"text":"ReducerProtocol","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/reducerprotocol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/MigratingToTheReducerProtocol":{"abstract":[{"type":"text","text":"Learn how to migrate existing applications to use the new "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol","type":"reference","isActive":true},{"type":"text","text":", in both Swift 5.7 and"},{"text":" ","type":"text"},{"type":"text","text":"Swift 5.6."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/MigratingToTheReducerProtocol","type":"topic","role":"article","title":"Migrating to the reducer protocol","url":"\/documentation\/composablearchitecture\/migratingtothereducerprotocol","kind":"article"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/exhaustivity":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/exhaustivity","kind":"symbol","type":"topic","title":"exhaustivity","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"exhaustivity"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:22ComposableArchitecture12ExhaustivityO","kind":"typeIdentifier","text":"Exhaustivity"}],"url":"\/documentation\/composablearchitecture\/teststore\/exhaustivity","abstract":[{"type":"text","text":"The current exhaustivity level of the test store."}],"role":"symbol"},"https://vimeo.com/751173570":{"url":"https:\/\/vimeo.com\/751173570","title":"conference talk","identifier":"https:\/\/vimeo.com\/751173570","titleInlineContent":[{"text":"conference talk","type":"text"}],"type":"link"},"#Testing-state-changes":{"url":"#Testing-state-changes","title":"Testing state changes","identifier":"#Testing-state-changes","titleInlineContent":[{"text":"Testing state changes","type":"text"}],"type":"link"},"http://github.com/pointfreeco/swift-clocks":{"url":"http:\/\/github.com\/pointfreeco\/swift-clocks","title":"Clocks","identifier":"http:\/\/github.com\/pointfreeco\/swift-clocks","titleInlineContent":[{"text":"Clocks","type":"text"}],"type":"link"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore/receive(_:timeout:assert:file:line:)-1rwdd":{"type":"topic","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"Asserts an action was received from an effect and asserts how the state changes."}],"fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"receive"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Action"},{"text":", ","kind":"text"},{"text":"timeout","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"UInt64","preciseIdentifier":"s:s6UInt64V"},{"text":"?, ","kind":"text"},{"text":"assert","kind":"externalParam"},{"kind":"text","text":": (("},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"text":"ScopedState","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"},{"text":" -> ","kind":"text"},{"preciseIdentifier":"s:s4Voida","text":"Void","kind":"typeIdentifier"},{"kind":"text","text":")?, "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"StaticString","preciseIdentifier":"s:s12StaticStringV"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore\/receive(_:timeout:assert:file:line:)-1rwdd","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Action"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" and "},{"code":"ScopedState","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"title":"receive(_:timeout:assert:file:line:)","url":"\/documentation\/composablearchitecture\/teststore\/receive(_:timeout:assert:file:line:)-1rwdd"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/EffectPublisher/run(priority:operation:catch:file:fileID:line:)":{"kind":"symbol","role":"symbol","conformance":{"constraints":[{"code":"Failure","type":"codeVoice"},{"type":"text","text":" is "},{"code":"Never","type":"codeVoice"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"abstract":[{"text":"Wraps an asynchronous unit of work that can emit any number of times in an effect.","type":"text"}],"fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"run"},{"text":"(","kind":"text"},{"text":"priority","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:ScP","text":"TaskPriority","kind":"typeIdentifier"},{"text":"?, ","kind":"text"},{"text":"operation","kind":"externalParam"},{"text":": (","kind":"text"},{"text":"Send","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture4SendV"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Action"},{"text":">) ","kind":"text"},{"text":"async","kind":"keyword"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"text":" -> ","kind":"text"},{"text":"Void","kind":"typeIdentifier","preciseIdentifier":"s:s4Voida"},{"text":", ","kind":"text"},{"text":"catch","kind":"externalParam"},{"text":": ((any ","kind":"text"},{"text":"Error","preciseIdentifier":"s:s5ErrorP","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Send","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture4SendV"},{"kind":"text","text":"<"},{"text":"Action","kind":"typeIdentifier"},{"text":">) ","kind":"text"},{"kind":"keyword","text":"async"},{"kind":"text","text":" -> "},{"text":"Void","kind":"typeIdentifier","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")?, "},{"text":"file","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:s12StaticStringV","text":"StaticString"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"fileID"},{"kind":"text","text":": "},{"preciseIdentifier":"s:s12StaticStringV","text":"StaticString","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"line"},{"text":": ","kind":"text"},{"text":"UInt","preciseIdentifier":"s:Su","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture15EffectPublisherV","text":"EffectPublisher"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Action"},{"text":", ","kind":"text"},{"text":"Failure","kind":"typeIdentifier"},{"kind":"text","text":">"}],"type":"topic","url":"\/documentation\/composablearchitecture\/effectpublisher\/run(priority:operation:catch:file:fileid:line:)","title":"run(priority:operation:catch:file:fileID:line:)","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/EffectPublisher\/run(priority:operation:catch:file:fileID:line:)"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Exhaustivity/off(showSkippedAssertions:)":{"title":"Exhaustivity.off(showSkippedAssertions:)","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Exhaustivity\/off(showSkippedAssertions:)","url":"\/documentation\/composablearchitecture\/exhaustivity\/off(showskippedassertions:)","type":"topic","fragments":[{"text":"case","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"off"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"showSkippedAssertions"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Sb","kind":"typeIdentifier","text":"Bool"},{"kind":"text","text":")"}],"abstract":[{"text":"Non-exhaustive assertions.","type":"text"}],"role":"symbol","kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"type":"topic","kind":"symbol","role":"symbol","title":"TestStore","navigatorTitle":[{"kind":"identifier","text":"TestStore"}],"fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"TestStore","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/teststore","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","abstract":[{"type":"text","text":"A testable runtime for a reducer."}]}}}