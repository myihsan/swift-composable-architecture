{"kind":"article","metadata":{"modules":[{"name":"ComposableArchitecture"}],"roleHeading":"Article","role":"article","title":"Dependencies"},"seeAlsoSections":[{"anchor":"Essentials","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance"],"generated":true,"title":"Essentials"}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"abstract":[{"text":"Learn how to register dependencies with the library so that they can be immediately accessible from","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"any reducer."}],"primaryContentSections":[{"content":[{"text":"Overview","anchor":"Overview","type":"heading","level":2},{"inlineContent":[{"text":"Dependencies in an application are the types and functions that need to interact with outside","type":"text"},{"type":"text","text":" "},{"type":"text","text":"systems that you do not control. Classic examples of this are API clients that make network requests"},{"type":"text","text":" "},{"text":"to servers, but also seemingly innocuous things such as ","type":"text"},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" initializers, and even"},{"type":"text","text":" "},{"text":"clocks, can be thought of as dependencies.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"By controlling the dependencies our features need to do their job we gain the ability to completely","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"alter the execution context a feature runs in. This means in tests and Xcode previews you can"},{"text":" ","type":"text"},{"type":"text","text":"provide a mock version of an API client that immediately returns some stubbed data rather than"},{"text":" ","type":"text"},{"text":"making a live network request to a server.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#The-need-for-controlled-dependencies"}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"#Using-library-dependencies","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"#Registering-your-own-dependencies"}]}]},{"content":[{"inlineContent":[{"identifier":"#Live-preview-and-test-dependencies","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"#Designing-dependencies","type":"reference"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","isActive":true,"identifier":"#Overriding-dependencies"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":2,"type":"heading","text":"The need for controlled dependencies","anchor":"The-need-for-controlled-dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose that you are building a todo application with a "},{"type":"codeVoice","code":"Todo"},{"text":" model that has a UUID identifier:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Todo: Equatable, Identifiable {","  let id: UUID","  var title = \"\"","  var isCompleted = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And suppose you have a reducer that handles an action for when the “Add todo” button is tapped,"},{"text":" ","type":"text"},{"text":"which appends a new todo to the end of the array:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  struct State {","    var todos: IdentifiedArrayOf<Todo> = []","    \/\/ ...","  }","  enum Action {","    case addButtonTapped","    \/\/ ...","  }","","  func reduce(into state: inout State, action: Action) -> EffectTask<Action> {","    switch action {","    case .addButtonTapped:","      state.todos.append(Todo(id: UUID())","      return .none","","    \/\/ ...","    }","  }","}"]},{"name":"Tip","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We are using "},{"type":"codeVoice","code":"IdentifiedArray"},{"text":" from our","type":"text"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections","isActive":true,"type":"reference"},{"text":" library because it provides a safe and","type":"text"},{"type":"text","text":" "},{"text":"ergonomic API for accessing elements from a stable ID rather than positional indices.","type":"text"}]}],"style":"tip"},{"type":"paragraph","inlineContent":[{"text":"In the reducer we are using the uncontrolled ","type":"text"},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" initializer from Foundation. Every invocation"},{"type":"text","text":" "},{"text":"of the initializer produces a fully random UUID. That may seem like what we want, but unfortunately","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it wreaks havoc on our ability to test."}]},{"inlineContent":[{"type":"text","text":"If we tried writing a test for the add todo functionality we will quickly find that we can’t"},{"type":"text","text":" "},{"type":"text","text":"possibly predict what UUID will be produced for the new todo:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testAddTodo() async {","  let store = TestStore(","    initialState: Todos.State(), ","    reducer: Todos()","  )","","  await store.send(.addButtonTapped) {","    $0.todos = [","      Todo(id: ???)","    ]","  }","}"]},{"type":"aside","style":"tip","content":[{"inlineContent":[{"type":"text","text":"Read the "},{"text":"doc:Testing","type":"text"},{"type":"text","text":" article to learn how to write tests for state mutations and effect"},{"text":" ","type":"text"},{"text":"execution in your features.","type":"text"}],"type":"paragraph"}],"name":"Tip"},{"inlineContent":[{"type":"text","text":"There is no way to get this test to pass."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This is why controlling dependencies is important. It allows us to substitute a UUID generator that","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is deterministic in tests, such as one that simply increments by 1 every time it is invoked."}]},{"inlineContent":[{"type":"text","text":"The library comes with a controlled UUID generator and can be accessed by using the"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" property wrapper to add a dependency to the "},{"type":"codeVoice","code":"Todos"},{"type":"text","text":" reducer:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  @Dependency(\\.uuid) var uuid","  \/\/ ...","}"]},{"inlineContent":[{"type":"text","text":"Then when you need a new UUID you should reach for the dependency rather than reaching for the"},{"text":" ","type":"text"},{"type":"text","text":"uncontrollable UUID initializer:"}],"type":"paragraph"},{"code":["case .addButtonTapped:","  state.todos.append(Todo(id: self.uuid()) \/\/ ⬅️","  return .none"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you do this little bit of upfront work you instantly unlock the ability to test the feature by"},{"text":" ","type":"text"},{"text":"providing a controlled, deterministic version of the UUID generator in tests. The library even comes","type":"text"},{"text":" ","type":"text"},{"text":"with such a version for the UUID generator, and it is called ","type":"text"},{"type":"codeVoice","code":"incrementing"},{"text":". You can override","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the dependency directly on the "},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"reference"},{"type":"text","text":" so that your feature’s reducer uses that version"},{"type":"text","text":" "},{"text":"instead of the live one:","type":"text"}]},{"syntax":"swift","code":["@MainActor","func testAddTodo() async {","  let store = TestStore(","    initialState: Todos.State(), ","    reducer: Todos()","  )","","  store.dependencies.uuid = .incrementing","","  await store.send(.addButtonTapped) {","    $0.todos = [","      Todo(id: UUID(string: \"00000000-0000-0000-0000-000000000000\")!)","    ]","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This test will pass deterministically, 100% of the time, and this is why it is so important to"},{"type":"text","text":" "},{"text":"control dependencies that interact with outside systems.","type":"text"}]},{"level":2,"anchor":"Using-library-dependencies","type":"heading","text":"Using library dependencies"},{"type":"paragraph","inlineContent":[{"text":"The library comes with many common dependencies that can be used in a controllable manner, such as","type":"text"},{"type":"text","text":" "},{"text":"date generators, clocks, random number generators, UUID generators, and more.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a feature that needs access to a date initializer, the continuous"},{"type":"text","text":" "},{"text":"clock for time-based asynchrony, and a UUID initializer. All 3 dependencies can be added to your","type":"text"},{"type":"text","text":" "},{"text":"feature’s reducer:","type":"text"}]},{"type":"codeListing","code":["struct Todos: ReducerProtocol {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","  @Dependency(\\.date) var date","  @Dependency(\\.continuousClock) var clock","  @Dependency(\\.uuid) var uuid","","  \/\/ ...","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, all 3 dependencies can easily be overridden with deterministic versions when testing the"},{"type":"text","text":" "},{"type":"text","text":"feature:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testTodos() async {","  let store = TestStore(","    initialState: Todos.State(),","    reducer: Todos()","  )","","  store.dependencies.date = .constant(Date(timeIntervalSinceReferenceDate: 1234567890))","  store.dependencies.continuousClock = ImmediateClock()","  store.dependencies.uuid = .incrementing","","  \/\/ ...","}"]},{"anchor":"Registering-your-own-dependencies","text":"Registering your own dependencies","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Although the library comes with many controllable dependencies out of the box, there are still"},{"type":"text","text":" "},{"type":"text","text":"times when you want to register your own dependencies with the library so that you can use the"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"text":" property wrapper. Doing this is quite similar to  registering an","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues","isActive":true,"type":"reference"},{"text":" in SwiftUI.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"First you create a type that conforms to the "},{"type":"codeVoice","code":"DependencyKey"},{"text":" protocol. The minimum implementation","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you must provide is a "},{"type":"codeVoice","code":"liveValue"},{"text":", which is the value used when running the app in a simulator or","type":"text"},{"type":"text","text":" "},{"type":"text","text":"on device, and so it’s appropriate for it to actually make network requests to an external server:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["private enum APIClientKey: DependencyKey {","  static let liveValue = APIClient.live","}"]},{"content":[{"type":"paragraph","inlineContent":[{"text":"There are two other values you can provide for a dependency. If you implement ","type":"text"},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" "},{"type":"text","text":"it will be used when testing features in a "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"reference","isActive":true},{"type":"text","text":", and if you implement "},{"type":"codeVoice","code":"previewValue"},{"text":" it","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"will be used while running features in an Xcode preview. You don’t need to worry about those"},{"type":"text","text":" "},{"text":"values when you are just getting started, and instead can","type":"text"},{"type":"text","text":" "},{"overridingTitle":"add them later","isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"add them later"}],"identifier":"#Live-preview-and-test-dependencies","type":"reference"},{"type":"text","text":"."}]}],"style":"tip","type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"text":"Finally, an extension must be made to ","type":"text"},{"type":"codeVoice","code":"DependencyValues"},{"type":"text","text":" to expose a computed property for the"},{"text":" ","type":"text"},{"text":"dependency:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["extension DependencyValues {","  var apiClient: APIClient {","    get { self[APIClientKey.self] }","    set { self[APIClientKey.self] = newValue }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With those few steps completed you can instantly access your API client dependency from any"},{"type":"text","text":" "},{"type":"text","text":"feature’s reducer by using the "},{"type":"codeVoice","code":"@Dependency"},{"text":" property wrapper:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  @Dependency(\\.apiClient) var apiClient","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will automatically use the live dependency in previews, simulators and devices, and in"},{"text":" ","type":"text"},{"type":"text","text":"tests you can override any endpoint of the dependency to return mock data:"}]},{"code":["@MainActor","func testFetchUser() async {","  let store = TestStore(","    initialState: Todos.State(),","    reducer: Todos()","  )","","  store.dependencies.apiClient.fetchUser = { _ in User(id: 1, name: \"Blob\") }","","  await store.send(.loadButtonTapped)","  await store.receive(.userResponse(.success(User(id: 1, name: \"Blob\")))) {","    $0.loadedUser = User(id: 1, name: \"Blob\")","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Often times it is not necessary to create a whole new type to conform to ","type":"text"},{"code":"DependencyKey","type":"codeVoice"},{"type":"text","text":". If the"},{"text":" ","type":"text"},{"type":"text","text":"dependency you are registering is a type that you own, then you can conform it directly to the"},{"type":"text","text":" "},{"type":"text","text":"protocol:"}],"type":"paragraph"},{"type":"codeListing","code":["extension APIClient: DependencyKey {","  static let liveValue = APIClient.live","}","","extension DependencyValues {","  var apiClient: APIClient {","    get { self[APIClient.self] }","    set { self[APIClient.self] = newValue }","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"That can save a little bit of boilerplate.","type":"text"}]},{"level":2,"text":"Live, preview and test dependencies","anchor":"Live-preview-and-test-dependencies","type":"heading"},{"inlineContent":[{"type":"text","text":"In the previous section we showed that to conform to "},{"type":"codeVoice","code":"DependencyKey"},{"type":"text","text":" you must provide "},{"inlineContent":[{"text":"at least","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"a "},{"type":"codeVoice","code":"liveValue"},{"text":", which is the default version of the dependency that is used when running on a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"device or simulator. The "},{"type":"codeVoice","code":"DependencyKey"},{"text":" protocol inherits from a base protocol,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"TestDependencyKey"},{"text":", which has 2 other requirements, ","type":"text"},{"code":"testValue","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"previewValue","type":"codeVoice"},{"type":"text","text":". Both are"},{"text":" ","type":"text"},{"text":"optional and delegate to ","type":"text"},{"type":"codeVoice","code":"liveValue"},{"type":"text","text":" if not implemented."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"If you implement a static ","type":"text"},{"type":"codeVoice","code":"testValue"},{"type":"text","text":" property on your key, that value will be used when running"},{"type":"text","text":" "},{"text":"your feature in a ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"reference","isActive":true},{"type":"text","text":". This is a great opportunity to supply a mocked version of the"},{"text":" ","type":"text"},{"text":"dependency that does not reach out to the real world. By doing this you can guarantee that your","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"tests will never accidentally make a network request, or track analytics events that are not"},{"type":"text","text":" "},{"type":"text","text":"actually tied to user actions, and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, we highly recommend you consider making your "},{"code":"testValue","type":"codeVoice"},{"text":" dependency into what we like to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"call an “unimplemented” dependency. This is a version of your dependency that performs an "},{"type":"codeVoice","code":"XCTFail"},{"text":" ","type":"text"},{"text":"in each endpoint so that if it is ever invoked in tests it will cause a test failure. This allows","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you to be more explicit about what dependencies are actually needed to test a particular user"},{"type":"text","text":" "},{"type":"text","text":"flow in your feature."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have an API client with endpoints for fetching a list of users or fetching"},{"type":"text","text":" "},{"text":"a particular user by id:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct APIClient {","  var fetchUser: (User.ID) async throws -> User","  var fetchUsers: () async throws -> [User]","}"]},{"type":"paragraph","inlineContent":[{"text":"Then we can construct an “unimplemented” version of this dependency that invokes ","type":"text"},{"code":"XCTFail","type":"codeVoice"},{"type":"text","text":" when"},{"type":"text","text":" "},{"text":"any endpoint is invoked","type":"text"}]},{"syntax":"swift","code":["extension APIClient {","  static let unimplemented = Self(","    fetchUser: { _ in XCTFail(\"APIClient.fetchUser unimplemented\") }","    fetchUsers: { XCTFail(\"APIClient.fetchUsers unimplemented\") }","  )","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" cannot be used in non-test targets, and so this instance cannot be defined"},{"text":" ","type":"text"},{"text":"in the same file where your dependency is registered. To work around this you can use our","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay","isActive":true},{"type":"text","text":" library that dynamically invokes "},{"type":"codeVoice","code":"XCTFail"},{"text":" and","type":"text"},{"text":" ","type":"text"},{"text":"it is automatically accessible when using the Composable Architecture. It also comes with some","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"helpers to ease the construction of these unimplemented values, which we can use when defining the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"testValue"},{"text":" of your dependency:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["import XCTestDynamicOverlay","","extension APIClient {","  static let testValue = Self(","    fetchUser: unimplemented(\"APIClient.fetchUser\")","    fetchUsers: unimplemented(\"APIClient.fetchUsers\")","  )","}"]},{"type":"paragraph","inlineContent":[{"text":"The other requirement of ","type":"text"},{"code":"TestDependencyKey","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"previewValue","type":"codeVoice"},{"text":", and if this value is implemented","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it will be used whenever your feature is run in an Xcode preview. Previews are similar to tests in"},{"type":"text","text":" "},{"type":"text","text":"that you usually do not want to interact with the outside world, such as making network requests."},{"text":" ","type":"text"},{"text":"In fact, many of Apple’s frameworks do not work in previews, such as Core Location, and so it will","type":"text"},{"type":"text","text":" "},{"type":"text","text":"be hard to interact with your feature in previews if it touches those frameworks."}]},{"inlineContent":[{"type":"text","text":"However, previews are dissimilar to tests in that it’s fine for dependencies to return some mock"},{"type":"text","text":" "},{"text":"data. There’s no need to deal with “unimplemented” clients for proving which dependencies are","type":"text"},{"type":"text","text":" "},{"type":"text","text":"actually used."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For the ","type":"text"},{"type":"codeVoice","code":"APIClient"},{"text":" example from above, we might define its ","type":"text"},{"code":"previewValue","type":"codeVoice"},{"type":"text","text":" like so:"}]},{"syntax":"swift","code":["extension APIClient: TestDependencyKey {","  static let previewValue = Self(","    fetchUsers: { ","      [","        User(id: 1, name: \"Blob\"),","        User(id: 1, name: \"Blob Jr.\"),","        User(id: 1, name: \"Blob Sr.\"),","      ]","    },","    fetchUser: { id in ","      User(id: id, name: \"Blob, id: \\(id)\")","    }","  )","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Then when running a feature that uses this dependency in an Xcode preview will immediately get","type":"text"},{"type":"text","text":" "},{"type":"text","text":"data provided to it, making it easier for you to iterate on your feature’s logic and styling."}]},{"level":2,"type":"heading","text":"Designing dependencies","anchor":"Designing-dependencies"},{"inlineContent":[{"text":"Making it possible to control your dependencies is the most important step you can take towards","type":"text"},{"text":" ","type":"text"},{"text":"making your features isolatable and testable. The second most important step after that is to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"design your dependencies in a way that maximizes their flexibility in tests and other situations."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The most popular way to design dependencies in Swift is to use protocols. For example, if your"},{"text":" ","type":"text"},{"type":"text","text":"feature needs to interact with an audio player, you might design a protocol with methods for"},{"type":"text","text":" "},{"text":"playing, stopping, and more:","type":"text"}],"type":"paragraph"},{"code":["protocol AudioPlayer {","  func loop(_ url: URL) async throws","  func play(_ url: URL) async throws ","  func setVolume(_ volume: Float) async","  func stop() async","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Then you are free to make as many conformances of this protocol as you want, such as a"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LiveAudioPlayer"},{"text":" that actually interacts with AVFoundation, or a ","type":"text"},{"type":"codeVoice","code":"MockAudioPlayer"},{"type":"text","text":" that doesn’t"},{"text":" ","type":"text"},{"type":"text","text":"play any sounds, but does suspend in order to simulate that something is playing. You could even"},{"type":"text","text":" "},{"text":"have an ","type":"text"},{"type":"codeVoice","code":"UnimplementedAudioPlayer"},{"text":" conformance that invokes ","type":"text"},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" when any method is invoked."},{"type":"text","text":" "},{"type":"text","text":"And all of those conformances can be used to specify the live, preview and test values for the"},{"text":" ","type":"text"},{"type":"text","text":"dependency:"}],"type":"paragraph"},{"code":["private enum AudioPlayerKey: DependencyKey {","  static let liveValue: any AudioPlayer = LiveAudioPlayer()","  static let previewValue: any AudioPlayer = MockAudioPlayer()","  static let testValue: any AudioPlayer = UnimplementedAudioPlayer()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This style of dependencies works just fine, and if it is what you are most comfortable with then","type":"text"},{"type":"text","text":" "},{"type":"text","text":"there is no need to change."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"However, there is a small change one can make to this dependency to unlock even more power. Rather","type":"text"},{"type":"text","text":" "},{"text":"than designing the audio player as a protocol, we can use a struct with closure properties to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"represent the interface:"}]},{"syntax":"swift","type":"codeListing","code":["struct AudioPlayerClient {","  var loop: (_ url: URL) async throws -> Void","  var play: (_ url: URL) async throws -> Void","  var setVolume: (_ volume: Float) async -> Void","  var stop: () async -> Void","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, rather than defining types that conform to the protocol you construct values:"}]},{"code":["extension AudioPlayerClient {","  static let live = Self(…)","  static let mock = Self(…)","  static let unimplemented = Self(…)","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And to register the dependency you can leverage the struct that defines the interface. There’s no"},{"text":" ","type":"text"},{"type":"text","text":"need to define a new type:"}]},{"code":["extension AudioPlayerClient: DependencyKey {","  static let liveValue = AudioPlayerClient.live","  static let previewValue = AudioPlayerClient.mock","  static let testValue = AudioPlayerClient.unimplemented","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"If you design your dependencies in this way you can pick which dependency endpoints you need in your","type":"text"},{"text":" ","type":"text"},{"text":"feature. For example, if you have a feature that needs an audio player to do its job, but it only","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"needs the "},{"type":"codeVoice","code":"play"},{"text":" endpoint, and doesn’t need to loop, set volume or stop audio, then you can specify","type":"text"},{"type":"text","text":" "},{"text":"a dependency on just that one function:","type":"text"}],"type":"paragraph"},{"code":["struct Feature: ReducerProtocol {","  @Dependency(\\.audioPlayer.play) var play","  \/\/ …","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This can allow your features to better describe the minimal interface they need from dependencies,"},{"type":"text","text":" "},{"text":"which can help a feature to seem less intimidating.","type":"text"}],"type":"paragraph"},{"text":"Overriding dependencies","level":2,"anchor":"Overriding-dependencies","type":"heading"},{"inlineContent":[{"type":"text","text":"It is possible to change the dependencies for just one particular reducer inside a larger composed"},{"type":"text","text":" "},{"type":"text","text":"reducer. This can be handy when running a feature in a more controlled environment where it may not be"},{"type":"text","text":" "},{"type":"text","text":"appropriate to communicate with the outside world."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, suppose you want to teach users how to use your feature through an onboarding"},{"text":" ","type":"text"},{"text":"experience. In such an experience it may not be appropriate for the user’s actions to cause","type":"text"},{"text":" ","type":"text"},{"text":"data to be written to disk, or user defaults to be written, or any number of things. It would be","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"better to use mock versions of those dependencies so that the user can interact with your feature"},{"text":" ","type":"text"},{"type":"text","text":"in a fully controlled environment."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"To do this you can use the ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/dependency(_:_:)","isActive":true},{"type":"text","text":" method to override a reducer’s"},{"text":" ","type":"text"},{"type":"text","text":"dependency with another value:"}]},{"code":["struct Onboarding: ReducerProtocol {","  var body: some ReducerProtocol<State, Action> {","    Reduce { state, action in ","      \/\/ Additional onboarding logic","    }","    Feature()","      .dependency(\\.userDefaults, .mock)","      .dependency(\\.database, .mock)","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This will cause the ","type":"text"},{"type":"codeVoice","code":"Feature"},{"text":" reducer to use a mock user defaults and database dependency, as well","type":"text"},{"text":" ","type":"text"},{"text":"as any reducer ","type":"text"},{"code":"Feature","type":"codeVoice"},{"type":"text","text":" uses under the hood, "},{"inlineContent":[{"text":"and","type":"text"}],"type":"emphasis"},{"type":"text","text":" any effects produced by "},{"type":"codeVoice","code":"Feature"},{"type":"text","text":"."}],"type":"paragraph"}],"kind":"content"}],"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/composablearchitecture\/dependencymanagement"]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"url":"\/documentation\/composablearchitecture\/performance","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","type":"topic","kind":"article","role":"article","abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"title":"Performance"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"title":"ComposableArchitecture","type":"topic","role":"collection","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","url":"\/documentation\/composablearchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"text":" ","type":"text"},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"kind":"symbol"},"#The-need-for-controlled-dependencies":{"url":"#The-need-for-controlled-dependencies","title":"The need for controlled dependencies","identifier":"#The-need-for-controlled-dependencies","titleInlineContent":[{"text":"The need for controlled dependencies","type":"text"}],"type":"link"},"#Designing-dependencies":{"url":"#Designing-dependencies","title":"Designing dependencies","identifier":"#Designing-dependencies","titleInlineContent":[{"text":"Designing dependencies","type":"text"}],"type":"link"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ReducerProtocol/dependency(_:_:)":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ReducerProtocol\/dependency(_:_:)","abstract":[{"type":"text","text":"Sets the dependency value of the specified key path to the given value."}],"fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"dependency","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Value","kind":"genericParameter"},{"kind":"text","text":">("},{"preciseIdentifier":"s:s15WritableKeyPathC","kind":"typeIdentifier","text":"WritableKeyPath"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:12Dependencies16DependencyValuesV","text":"DependencyValues"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"Value"},{"text":">, ","kind":"text"},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":") -> "},{"text":"_DependencyKeyWritingReducer","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":">"}],"role":"symbol","type":"topic","kind":"symbol","title":"dependency(_:_:)","url":"\/documentation\/composablearchitecture\/reducerprotocol\/dependency(_:_:)"},"https://github.com/pointfreeco/swift-identified-collections":{"title":"Identified Collections","type":"link","url":"https:\/\/github.com\/pointfreeco\/swift-identified-collections","titleInlineContent":[{"text":"Identified Collections","type":"text"}],"identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"},"#Overriding-dependencies":{"title":"Overriding dependencies","type":"link","url":"#Overriding-dependencies","titleInlineContent":[{"text":"Overriding dependencies","type":"text"}],"identifier":"#Overriding-dependencies"},"http://github.com/pointfreeco/xctest-dynamic-overlay":{"title":"XCTestDynamicOverlay","type":"link","url":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay","titleInlineContent":[{"text":"XCTestDynamicOverlay","type":"text"}],"identifier":"http:\/\/github.com\/pointfreeco\/xctest-dynamic-overlay"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"type":"topic","kind":"symbol","role":"symbol","title":"TestStore","navigatorTitle":[{"kind":"identifier","text":"TestStore"}],"fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"TestStore","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/teststore","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","abstract":[{"type":"text","text":"A testable runtime for a reducer."}]},"https://developer.apple.com/documentation/swiftui/environmentvalues":{"title":"environment value","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues","titleInlineContent":[{"text":"environment value","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"kind":"article","type":"topic","title":"Getting started","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","url":"\/documentation\/composablearchitecture\/gettingstarted","role":"article","abstract":[{"text":"Learn how to integrate the Composable Architecture into your project and write your first","type":"text"},{"text":" ","type":"text"},{"text":"application.","type":"text"}]},"#Using-library-dependencies":{"title":"Using library dependencies","type":"link","url":"#Using-library-dependencies","titleInlineContent":[{"text":"Using library dependencies","type":"text"}],"identifier":"#Using-library-dependencies"},"#Live-preview-and-test-dependencies":{"title":"Live, preview and test dependencies","type":"link","url":"#Live-preview-and-test-dependencies","titleInlineContent":[{"text":"Live, preview and test dependencies","type":"text"}],"identifier":"#Live-preview-and-test-dependencies"},"#Registering-your-own-dependencies":{"title":"Registering your own dependencies","type":"link","url":"#Registering-your-own-dependencies","titleInlineContent":[{"text":"Registering your own dependencies","type":"text"}],"identifier":"#Registering-your-own-dependencies"}}}